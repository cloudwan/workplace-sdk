// Code generated by protoc-gen-goten-object
// File: workplace/proto/v1alpha/common.proto
// DO NOT EDIT!!!

package workplace_common

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/iancoleman/strcase"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	latlng "google.golang.org/genproto/googleapis/type/latlng"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = fmt.Stringer(nil)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = proto.Message(nil)
	_ = protoregistry.GlobalTypes
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldPath(nil)
)

// make sure we're using proto imports
var (
	_ = &latlng.LatLng{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type BBox_FieldPath interface {
	gotenobject.FieldPath
	Selector() BBox_FieldPathSelector
	Get(source *BBox) []interface{}
	GetSingle(source *BBox) (interface{}, bool)
	ClearValue(item *BBox)

	// Those methods build corresponding BBox_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) BBox_FieldPathValue
	WithIArrayOfValues(values interface{}) BBox_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) BBox_FieldPathArrayItemValue
}

type BBox_FieldPathSelector int32

const (
	BBox_FieldPathSelectorSouthWest BBox_FieldPathSelector = 0
	BBox_FieldPathSelectorNorthEast BBox_FieldPathSelector = 1
)

func (s BBox_FieldPathSelector) String() string {
	switch s {
	case BBox_FieldPathSelectorSouthWest:
		return "south_west"
	case BBox_FieldPathSelectorNorthEast:
		return "north_east"
	default:
		panic(fmt.Sprintf("Invalid selector for BBox: %d", s))
	}
}

func BuildBBox_FieldPath(fp gotenobject.RawFieldPath) (BBox_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object BBox")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "south_west", "southWest", "south-west":
			return &BBox_FieldTerminalPath{selector: BBox_FieldPathSelectorSouthWest}, nil
		case "north_east", "northEast", "north-east":
			return &BBox_FieldTerminalPath{selector: BBox_FieldPathSelectorNorthEast}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object BBox", fp)
}

func ParseBBox_FieldPath(rawField string) (BBox_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBBox_FieldPath(fp)
}

func MustParseBBox_FieldPath(rawField string) BBox_FieldPath {
	fp, err := ParseBBox_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type BBox_FieldTerminalPath struct {
	selector BBox_FieldPathSelector
}

var _ BBox_FieldPath = (*BBox_FieldTerminalPath)(nil)

func (fp *BBox_FieldTerminalPath) Selector() BBox_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *BBox_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *BBox_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source BBox
func (fp *BBox_FieldTerminalPath) Get(source *BBox) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case BBox_FieldPathSelectorSouthWest:
			if source.SouthWest != nil {
				values = append(values, source.SouthWest)
			}
		case BBox_FieldPathSelectorNorthEast:
			if source.NorthEast != nil {
				values = append(values, source.NorthEast)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for BBox: %d", fp.selector))
		}
	}
	return
}

func (fp *BBox_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*BBox))
}

// GetSingle returns value pointed by specific field of from source BBox
func (fp *BBox_FieldTerminalPath) GetSingle(source *BBox) (interface{}, bool) {
	switch fp.selector {
	case BBox_FieldPathSelectorSouthWest:
		res := source.GetSouthWest()
		return res, res != nil
	case BBox_FieldPathSelectorNorthEast:
		res := source.GetNorthEast()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for BBox: %d", fp.selector))
	}
}

func (fp *BBox_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*BBox))
}

// GetDefault returns a default value of the field type
func (fp *BBox_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case BBox_FieldPathSelectorSouthWest:
		return (*latlng.LatLng)(nil)
	case BBox_FieldPathSelectorNorthEast:
		return (*latlng.LatLng)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for BBox: %d", fp.selector))
	}
}

func (fp *BBox_FieldTerminalPath) ClearValue(item *BBox) {
	if item != nil {
		switch fp.selector {
		case BBox_FieldPathSelectorSouthWest:
			item.SouthWest = nil
		case BBox_FieldPathSelectorNorthEast:
			item.NorthEast = nil
		default:
			panic(fmt.Sprintf("Invalid selector for BBox: %d", fp.selector))
		}
	}
}

func (fp *BBox_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*BBox))
}

// IsLeaf - whether field path is holds simple value
func (fp *BBox_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == BBox_FieldPathSelectorSouthWest ||
		fp.selector == BBox_FieldPathSelectorNorthEast
}

func (fp *BBox_FieldTerminalPath) WithIValue(value interface{}) BBox_FieldPathValue {
	switch fp.selector {
	case BBox_FieldPathSelectorSouthWest:
		return &BBox_FieldTerminalPathValue{BBox_FieldTerminalPath: *fp, value: value.(*latlng.LatLng)}
	case BBox_FieldPathSelectorNorthEast:
		return &BBox_FieldTerminalPathValue{BBox_FieldTerminalPath: *fp, value: value.(*latlng.LatLng)}
	default:
		panic(fmt.Sprintf("Invalid selector for BBox: %d", fp.selector))
	}
}

func (fp *BBox_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *BBox_FieldTerminalPath) WithIArrayOfValues(values interface{}) BBox_FieldPathArrayOfValues {
	fpaov := &BBox_FieldTerminalPathArrayOfValues{BBox_FieldTerminalPath: *fp}
	switch fp.selector {
	case BBox_FieldPathSelectorSouthWest:
		return &BBox_FieldTerminalPathArrayOfValues{BBox_FieldTerminalPath: *fp, values: values.([]*latlng.LatLng)}
	case BBox_FieldPathSelectorNorthEast:
		return &BBox_FieldTerminalPathArrayOfValues{BBox_FieldTerminalPath: *fp, values: values.([]*latlng.LatLng)}
	default:
		panic(fmt.Sprintf("Invalid selector for BBox: %d", fp.selector))
	}
	return fpaov
}

func (fp *BBox_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *BBox_FieldTerminalPath) WithIArrayItemValue(value interface{}) BBox_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for BBox: %d", fp.selector))
	}
}

func (fp *BBox_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// BBox_FieldPathValue allows storing values for BBox fields according to their type
type BBox_FieldPathValue interface {
	BBox_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **BBox)
	CompareWith(*BBox) (cmp int, comparable bool)
}

func ParseBBox_FieldPathValue(pathStr, valueStr string) (BBox_FieldPathValue, error) {
	fp, err := ParseBBox_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BBox field path value from %s: %v", valueStr, err)
	}
	return fpv.(BBox_FieldPathValue), nil
}

func MustParseBBox_FieldPathValue(pathStr, valueStr string) BBox_FieldPathValue {
	fpv, err := ParseBBox_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type BBox_FieldTerminalPathValue struct {
	BBox_FieldTerminalPath
	value interface{}
}

var _ BBox_FieldPathValue = (*BBox_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'BBox' as interface{}
func (fpv *BBox_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *BBox_FieldTerminalPathValue) AsSouthWestValue() (*latlng.LatLng, bool) {
	res, ok := fpv.value.(*latlng.LatLng)
	return res, ok
}
func (fpv *BBox_FieldTerminalPathValue) AsNorthEastValue() (*latlng.LatLng, bool) {
	res, ok := fpv.value.(*latlng.LatLng)
	return res, ok
}

// SetTo stores value for selected field for object BBox
func (fpv *BBox_FieldTerminalPathValue) SetTo(target **BBox) {
	if *target == nil {
		*target = new(BBox)
	}
	switch fpv.selector {
	case BBox_FieldPathSelectorSouthWest:
		(*target).SouthWest = fpv.value.(*latlng.LatLng)
	case BBox_FieldPathSelectorNorthEast:
		(*target).NorthEast = fpv.value.(*latlng.LatLng)
	default:
		panic(fmt.Sprintf("Invalid selector for BBox: %d", fpv.selector))
	}
}

func (fpv *BBox_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*BBox)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BBox_FieldTerminalPathValue' with the value under path in 'BBox'.
func (fpv *BBox_FieldTerminalPathValue) CompareWith(source *BBox) (int, bool) {
	switch fpv.selector {
	case BBox_FieldPathSelectorSouthWest:
		return 0, false
	case BBox_FieldPathSelectorNorthEast:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for BBox: %d", fpv.selector))
	}
}

func (fpv *BBox_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*BBox))
}

// BBox_FieldPathArrayItemValue allows storing single item in Path-specific values for BBox according to their type
// Present only for array (repeated) types.
type BBox_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	BBox_FieldPath
	ContainsValue(*BBox) bool
}

// ParseBBox_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBBox_FieldPathArrayItemValue(pathStr, valueStr string) (BBox_FieldPathArrayItemValue, error) {
	fp, err := ParseBBox_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BBox field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(BBox_FieldPathArrayItemValue), nil
}

func MustParseBBox_FieldPathArrayItemValue(pathStr, valueStr string) BBox_FieldPathArrayItemValue {
	fpaiv, err := ParseBBox_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type BBox_FieldTerminalPathArrayItemValue struct {
	BBox_FieldTerminalPath
	value interface{}
}

var _ BBox_FieldPathArrayItemValue = (*BBox_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object BBox as interface{}
func (fpaiv *BBox_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *BBox_FieldTerminalPathArrayItemValue) GetSingle(source *BBox) (interface{}, bool) {
	return nil, false
}

func (fpaiv *BBox_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*BBox))
}

// Contains returns a boolean indicating if value that is being held is present in given 'BBox'
func (fpaiv *BBox_FieldTerminalPathArrayItemValue) ContainsValue(source *BBox) bool {
	slice := fpaiv.BBox_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// BBox_FieldPathArrayOfValues allows storing slice of values for BBox fields according to their type
type BBox_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	BBox_FieldPath
}

func ParseBBox_FieldPathArrayOfValues(pathStr, valuesStr string) (BBox_FieldPathArrayOfValues, error) {
	fp, err := ParseBBox_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BBox field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(BBox_FieldPathArrayOfValues), nil
}

func MustParseBBox_FieldPathArrayOfValues(pathStr, valuesStr string) BBox_FieldPathArrayOfValues {
	fpaov, err := ParseBBox_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type BBox_FieldTerminalPathArrayOfValues struct {
	BBox_FieldTerminalPath
	values interface{}
}

var _ BBox_FieldPathArrayOfValues = (*BBox_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *BBox_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case BBox_FieldPathSelectorSouthWest:
		for _, v := range fpaov.values.([]*latlng.LatLng) {
			values = append(values, v)
		}
	case BBox_FieldPathSelectorNorthEast:
		for _, v := range fpaov.values.([]*latlng.LatLng) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *BBox_FieldTerminalPathArrayOfValues) AsSouthWestArrayOfValues() ([]*latlng.LatLng, bool) {
	res, ok := fpaov.values.([]*latlng.LatLng)
	return res, ok
}
func (fpaov *BBox_FieldTerminalPathArrayOfValues) AsNorthEastArrayOfValues() ([]*latlng.LatLng, bool) {
	res, ok := fpaov.values.([]*latlng.LatLng)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Polygon_FieldPath interface {
	gotenobject.FieldPath
	Selector() Polygon_FieldPathSelector
	Get(source *Polygon) []interface{}
	GetSingle(source *Polygon) (interface{}, bool)
	ClearValue(item *Polygon)

	// Those methods build corresponding Polygon_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Polygon_FieldPathValue
	WithIArrayOfValues(values interface{}) Polygon_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Polygon_FieldPathArrayItemValue
}

type Polygon_FieldPathSelector int32

const (
	Polygon_FieldPathSelectorCoordinates Polygon_FieldPathSelector = 0
)

func (s Polygon_FieldPathSelector) String() string {
	switch s {
	case Polygon_FieldPathSelectorCoordinates:
		return "coordinates"
	default:
		panic(fmt.Sprintf("Invalid selector for Polygon: %d", s))
	}
}

func BuildPolygon_FieldPath(fp gotenobject.RawFieldPath) (Polygon_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Polygon")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "coordinates":
			return &Polygon_FieldTerminalPath{selector: Polygon_FieldPathSelectorCoordinates}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Polygon", fp)
}

func ParsePolygon_FieldPath(rawField string) (Polygon_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildPolygon_FieldPath(fp)
}

func MustParsePolygon_FieldPath(rawField string) Polygon_FieldPath {
	fp, err := ParsePolygon_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Polygon_FieldTerminalPath struct {
	selector Polygon_FieldPathSelector
}

var _ Polygon_FieldPath = (*Polygon_FieldTerminalPath)(nil)

func (fp *Polygon_FieldTerminalPath) Selector() Polygon_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Polygon_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Polygon_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Polygon
func (fp *Polygon_FieldTerminalPath) Get(source *Polygon) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Polygon_FieldPathSelectorCoordinates:
			for _, value := range source.GetCoordinates() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Polygon: %d", fp.selector))
		}
	}
	return
}

func (fp *Polygon_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Polygon))
}

// GetSingle returns value pointed by specific field of from source Polygon
func (fp *Polygon_FieldTerminalPath) GetSingle(source *Polygon) (interface{}, bool) {
	switch fp.selector {
	case Polygon_FieldPathSelectorCoordinates:
		res := source.GetCoordinates()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Polygon: %d", fp.selector))
	}
}

func (fp *Polygon_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Polygon))
}

// GetDefault returns a default value of the field type
func (fp *Polygon_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Polygon_FieldPathSelectorCoordinates:
		return ([]*latlng.LatLng)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Polygon: %d", fp.selector))
	}
}

func (fp *Polygon_FieldTerminalPath) ClearValue(item *Polygon) {
	if item != nil {
		switch fp.selector {
		case Polygon_FieldPathSelectorCoordinates:
			item.Coordinates = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Polygon: %d", fp.selector))
		}
	}
}

func (fp *Polygon_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Polygon))
}

// IsLeaf - whether field path is holds simple value
func (fp *Polygon_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Polygon_FieldPathSelectorCoordinates
}

func (fp *Polygon_FieldTerminalPath) WithIValue(value interface{}) Polygon_FieldPathValue {
	switch fp.selector {
	case Polygon_FieldPathSelectorCoordinates:
		return &Polygon_FieldTerminalPathValue{Polygon_FieldTerminalPath: *fp, value: value.([]*latlng.LatLng)}
	default:
		panic(fmt.Sprintf("Invalid selector for Polygon: %d", fp.selector))
	}
}

func (fp *Polygon_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Polygon_FieldTerminalPath) WithIArrayOfValues(values interface{}) Polygon_FieldPathArrayOfValues {
	fpaov := &Polygon_FieldTerminalPathArrayOfValues{Polygon_FieldTerminalPath: *fp}
	switch fp.selector {
	case Polygon_FieldPathSelectorCoordinates:
		return &Polygon_FieldTerminalPathArrayOfValues{Polygon_FieldTerminalPath: *fp, values: values.([][]*latlng.LatLng)}
	default:
		panic(fmt.Sprintf("Invalid selector for Polygon: %d", fp.selector))
	}
	return fpaov
}

func (fp *Polygon_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Polygon_FieldTerminalPath) WithIArrayItemValue(value interface{}) Polygon_FieldPathArrayItemValue {
	switch fp.selector {
	case Polygon_FieldPathSelectorCoordinates:
		return &Polygon_FieldTerminalPathArrayItemValue{Polygon_FieldTerminalPath: *fp, value: value.(*latlng.LatLng)}
	default:
		panic(fmt.Sprintf("Invalid selector for Polygon: %d", fp.selector))
	}
}

func (fp *Polygon_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Polygon_FieldPathValue allows storing values for Polygon fields according to their type
type Polygon_FieldPathValue interface {
	Polygon_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Polygon)
	CompareWith(*Polygon) (cmp int, comparable bool)
}

func ParsePolygon_FieldPathValue(pathStr, valueStr string) (Polygon_FieldPathValue, error) {
	fp, err := ParsePolygon_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Polygon field path value from %s: %v", valueStr, err)
	}
	return fpv.(Polygon_FieldPathValue), nil
}

func MustParsePolygon_FieldPathValue(pathStr, valueStr string) Polygon_FieldPathValue {
	fpv, err := ParsePolygon_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Polygon_FieldTerminalPathValue struct {
	Polygon_FieldTerminalPath
	value interface{}
}

var _ Polygon_FieldPathValue = (*Polygon_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Polygon' as interface{}
func (fpv *Polygon_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Polygon_FieldTerminalPathValue) AsCoordinatesValue() ([]*latlng.LatLng, bool) {
	res, ok := fpv.value.([]*latlng.LatLng)
	return res, ok
}

// SetTo stores value for selected field for object Polygon
func (fpv *Polygon_FieldTerminalPathValue) SetTo(target **Polygon) {
	if *target == nil {
		*target = new(Polygon)
	}
	switch fpv.selector {
	case Polygon_FieldPathSelectorCoordinates:
		(*target).Coordinates = fpv.value.([]*latlng.LatLng)
	default:
		panic(fmt.Sprintf("Invalid selector for Polygon: %d", fpv.selector))
	}
}

func (fpv *Polygon_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Polygon)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Polygon_FieldTerminalPathValue' with the value under path in 'Polygon'.
func (fpv *Polygon_FieldTerminalPathValue) CompareWith(source *Polygon) (int, bool) {
	switch fpv.selector {
	case Polygon_FieldPathSelectorCoordinates:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Polygon: %d", fpv.selector))
	}
}

func (fpv *Polygon_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Polygon))
}

// Polygon_FieldPathArrayItemValue allows storing single item in Path-specific values for Polygon according to their type
// Present only for array (repeated) types.
type Polygon_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Polygon_FieldPath
	ContainsValue(*Polygon) bool
}

// ParsePolygon_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParsePolygon_FieldPathArrayItemValue(pathStr, valueStr string) (Polygon_FieldPathArrayItemValue, error) {
	fp, err := ParsePolygon_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Polygon field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Polygon_FieldPathArrayItemValue), nil
}

func MustParsePolygon_FieldPathArrayItemValue(pathStr, valueStr string) Polygon_FieldPathArrayItemValue {
	fpaiv, err := ParsePolygon_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Polygon_FieldTerminalPathArrayItemValue struct {
	Polygon_FieldTerminalPath
	value interface{}
}

var _ Polygon_FieldPathArrayItemValue = (*Polygon_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Polygon as interface{}
func (fpaiv *Polygon_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *Polygon_FieldTerminalPathArrayItemValue) AsCoordinatesItemValue() (*latlng.LatLng, bool) {
	res, ok := fpaiv.value.(*latlng.LatLng)
	return res, ok
}

func (fpaiv *Polygon_FieldTerminalPathArrayItemValue) GetSingle(source *Polygon) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Polygon_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Polygon))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Polygon'
func (fpaiv *Polygon_FieldTerminalPathArrayItemValue) ContainsValue(source *Polygon) bool {
	slice := fpaiv.Polygon_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Polygon_FieldPathArrayOfValues allows storing slice of values for Polygon fields according to their type
type Polygon_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Polygon_FieldPath
}

func ParsePolygon_FieldPathArrayOfValues(pathStr, valuesStr string) (Polygon_FieldPathArrayOfValues, error) {
	fp, err := ParsePolygon_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Polygon field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Polygon_FieldPathArrayOfValues), nil
}

func MustParsePolygon_FieldPathArrayOfValues(pathStr, valuesStr string) Polygon_FieldPathArrayOfValues {
	fpaov, err := ParsePolygon_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Polygon_FieldTerminalPathArrayOfValues struct {
	Polygon_FieldTerminalPath
	values interface{}
}

var _ Polygon_FieldPathArrayOfValues = (*Polygon_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Polygon_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Polygon_FieldPathSelectorCoordinates:
		for _, v := range fpaov.values.([][]*latlng.LatLng) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Polygon_FieldTerminalPathArrayOfValues) AsCoordinatesArrayOfValues() ([][]*latlng.LatLng, bool) {
	res, ok := fpaov.values.([][]*latlng.LatLng)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Geometry_FieldPath interface {
	gotenobject.FieldPath
	Selector() Geometry_FieldPathSelector
	Get(source *Geometry) []interface{}
	GetSingle(source *Geometry) (interface{}, bool)
	ClearValue(item *Geometry)

	// Those methods build corresponding Geometry_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Geometry_FieldPathValue
	WithIArrayOfValues(values interface{}) Geometry_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Geometry_FieldPathArrayItemValue
}

type Geometry_FieldPathSelector int32

const (
	Geometry_FieldPathSelectorCenter  Geometry_FieldPathSelector = 0
	Geometry_FieldPathSelectorBbox    Geometry_FieldPathSelector = 1
	Geometry_FieldPathSelectorPolygon Geometry_FieldPathSelector = 2
	Geometry_FieldPathSelectorPanning Geometry_FieldPathSelector = 3
)

func (s Geometry_FieldPathSelector) String() string {
	switch s {
	case Geometry_FieldPathSelectorCenter:
		return "center"
	case Geometry_FieldPathSelectorBbox:
		return "bbox"
	case Geometry_FieldPathSelectorPolygon:
		return "polygon"
	case Geometry_FieldPathSelectorPanning:
		return "panning"
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", s))
	}
}

func BuildGeometry_FieldPath(fp gotenobject.RawFieldPath) (Geometry_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Geometry")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "center":
			return &Geometry_FieldTerminalPath{selector: Geometry_FieldPathSelectorCenter}, nil
		case "bbox":
			return &Geometry_FieldTerminalPath{selector: Geometry_FieldPathSelectorBbox}, nil
		case "polygon":
			return &Geometry_FieldTerminalPath{selector: Geometry_FieldPathSelectorPolygon}, nil
		case "panning":
			return &Geometry_FieldTerminalPath{selector: Geometry_FieldPathSelectorPanning}, nil
		}
	} else {
		switch fp[0] {
		case "bbox":
			if subpath, err := BuildBBox_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Geometry_FieldSubPath{selector: Geometry_FieldPathSelectorBbox, subPath: subpath}, nil
			}
		case "polygon":
			if subpath, err := BuildPolygon_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Geometry_FieldSubPath{selector: Geometry_FieldPathSelectorPolygon, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Geometry", fp)
}

func ParseGeometry_FieldPath(rawField string) (Geometry_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildGeometry_FieldPath(fp)
}

func MustParseGeometry_FieldPath(rawField string) Geometry_FieldPath {
	fp, err := ParseGeometry_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Geometry_FieldTerminalPath struct {
	selector Geometry_FieldPathSelector
}

var _ Geometry_FieldPath = (*Geometry_FieldTerminalPath)(nil)

func (fp *Geometry_FieldTerminalPath) Selector() Geometry_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Geometry_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Geometry_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Geometry
func (fp *Geometry_FieldTerminalPath) Get(source *Geometry) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Geometry_FieldPathSelectorCenter:
			if source.Center != nil {
				values = append(values, source.Center)
			}
		case Geometry_FieldPathSelectorBbox:
			if source.Bbox != nil {
				values = append(values, source.Bbox)
			}
		case Geometry_FieldPathSelectorPolygon:
			if source.Polygon != nil {
				values = append(values, source.Polygon)
			}
		case Geometry_FieldPathSelectorPanning:
			values = append(values, source.Panning)
		default:
			panic(fmt.Sprintf("Invalid selector for Geometry: %d", fp.selector))
		}
	}
	return
}

func (fp *Geometry_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Geometry))
}

// GetSingle returns value pointed by specific field of from source Geometry
func (fp *Geometry_FieldTerminalPath) GetSingle(source *Geometry) (interface{}, bool) {
	switch fp.selector {
	case Geometry_FieldPathSelectorCenter:
		res := source.GetCenter()
		return res, res != nil
	case Geometry_FieldPathSelectorBbox:
		res := source.GetBbox()
		return res, res != nil
	case Geometry_FieldPathSelectorPolygon:
		res := source.GetPolygon()
		return res, res != nil
	case Geometry_FieldPathSelectorPanning:
		return source.GetPanning(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fp.selector))
	}
}

func (fp *Geometry_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Geometry))
}

// GetDefault returns a default value of the field type
func (fp *Geometry_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Geometry_FieldPathSelectorCenter:
		return (*latlng.LatLng)(nil)
	case Geometry_FieldPathSelectorBbox:
		return (*BBox)(nil)
	case Geometry_FieldPathSelectorPolygon:
		return (*Polygon)(nil)
	case Geometry_FieldPathSelectorPanning:
		return float64(0)
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fp.selector))
	}
}

func (fp *Geometry_FieldTerminalPath) ClearValue(item *Geometry) {
	if item != nil {
		switch fp.selector {
		case Geometry_FieldPathSelectorCenter:
			item.Center = nil
		case Geometry_FieldPathSelectorBbox:
			item.Bbox = nil
		case Geometry_FieldPathSelectorPolygon:
			item.Polygon = nil
		case Geometry_FieldPathSelectorPanning:
			item.Panning = float64(0)
		default:
			panic(fmt.Sprintf("Invalid selector for Geometry: %d", fp.selector))
		}
	}
}

func (fp *Geometry_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Geometry))
}

// IsLeaf - whether field path is holds simple value
func (fp *Geometry_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Geometry_FieldPathSelectorCenter ||
		fp.selector == Geometry_FieldPathSelectorPanning
}

func (fp *Geometry_FieldTerminalPath) WithIValue(value interface{}) Geometry_FieldPathValue {
	switch fp.selector {
	case Geometry_FieldPathSelectorCenter:
		return &Geometry_FieldTerminalPathValue{Geometry_FieldTerminalPath: *fp, value: value.(*latlng.LatLng)}
	case Geometry_FieldPathSelectorBbox:
		return &Geometry_FieldTerminalPathValue{Geometry_FieldTerminalPath: *fp, value: value.(*BBox)}
	case Geometry_FieldPathSelectorPolygon:
		return &Geometry_FieldTerminalPathValue{Geometry_FieldTerminalPath: *fp, value: value.(*Polygon)}
	case Geometry_FieldPathSelectorPanning:
		return &Geometry_FieldTerminalPathValue{Geometry_FieldTerminalPath: *fp, value: value.(float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fp.selector))
	}
}

func (fp *Geometry_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Geometry_FieldTerminalPath) WithIArrayOfValues(values interface{}) Geometry_FieldPathArrayOfValues {
	fpaov := &Geometry_FieldTerminalPathArrayOfValues{Geometry_FieldTerminalPath: *fp}
	switch fp.selector {
	case Geometry_FieldPathSelectorCenter:
		return &Geometry_FieldTerminalPathArrayOfValues{Geometry_FieldTerminalPath: *fp, values: values.([]*latlng.LatLng)}
	case Geometry_FieldPathSelectorBbox:
		return &Geometry_FieldTerminalPathArrayOfValues{Geometry_FieldTerminalPath: *fp, values: values.([]*BBox)}
	case Geometry_FieldPathSelectorPolygon:
		return &Geometry_FieldTerminalPathArrayOfValues{Geometry_FieldTerminalPath: *fp, values: values.([]*Polygon)}
	case Geometry_FieldPathSelectorPanning:
		return &Geometry_FieldTerminalPathArrayOfValues{Geometry_FieldTerminalPath: *fp, values: values.([]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fp.selector))
	}
	return fpaov
}

func (fp *Geometry_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Geometry_FieldTerminalPath) WithIArrayItemValue(value interface{}) Geometry_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fp.selector))
	}
}

func (fp *Geometry_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type Geometry_FieldSubPath struct {
	selector Geometry_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ Geometry_FieldPath = (*Geometry_FieldSubPath)(nil)

func (fps *Geometry_FieldSubPath) Selector() Geometry_FieldPathSelector {
	return fps.selector
}
func (fps *Geometry_FieldSubPath) AsBboxSubPath() (BBox_FieldPath, bool) {
	res, ok := fps.subPath.(BBox_FieldPath)
	return res, ok
}
func (fps *Geometry_FieldSubPath) AsPolygonSubPath() (Polygon_FieldPath, bool) {
	res, ok := fps.subPath.(Polygon_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *Geometry_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *Geometry_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source Geometry
func (fps *Geometry_FieldSubPath) Get(source *Geometry) (values []interface{}) {
	if asBBoxFieldPath, ok := fps.AsBboxSubPath(); ok {
		values = append(values, asBBoxFieldPath.Get(source.GetBbox())...)
	} else if asPolygonFieldPath, ok := fps.AsPolygonSubPath(); ok {
		values = append(values, asPolygonFieldPath.Get(source.GetPolygon())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fps.selector))
	}
	return
}

func (fps *Geometry_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*Geometry))
}

// GetSingle returns value of selected field from source Geometry
func (fps *Geometry_FieldSubPath) GetSingle(source *Geometry) (interface{}, bool) {
	switch fps.selector {
	case Geometry_FieldPathSelectorBbox:
		if source.GetBbox() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetBbox())
	case Geometry_FieldPathSelectorPolygon:
		if source.GetPolygon() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetPolygon())
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fps.selector))
	}
}

func (fps *Geometry_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*Geometry))
}

// GetDefault returns a default value of the field type
func (fps *Geometry_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *Geometry_FieldSubPath) ClearValue(item *Geometry) {
	if item != nil {
		switch fps.selector {
		case Geometry_FieldPathSelectorBbox:
			fps.subPath.ClearValueRaw(item.Bbox)
		case Geometry_FieldPathSelectorPolygon:
			fps.subPath.ClearValueRaw(item.Polygon)
		default:
			panic(fmt.Sprintf("Invalid selector for Geometry: %d", fps.selector))
		}
	}
}

func (fps *Geometry_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*Geometry))
}

// IsLeaf - whether field path is holds simple value
func (fps *Geometry_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *Geometry_FieldSubPath) WithIValue(value interface{}) Geometry_FieldPathValue {
	return &Geometry_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *Geometry_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *Geometry_FieldSubPath) WithIArrayOfValues(values interface{}) Geometry_FieldPathArrayOfValues {
	return &Geometry_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *Geometry_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *Geometry_FieldSubPath) WithIArrayItemValue(value interface{}) Geometry_FieldPathArrayItemValue {
	return &Geometry_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *Geometry_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// Geometry_FieldPathValue allows storing values for Geometry fields according to their type
type Geometry_FieldPathValue interface {
	Geometry_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Geometry)
	CompareWith(*Geometry) (cmp int, comparable bool)
}

func ParseGeometry_FieldPathValue(pathStr, valueStr string) (Geometry_FieldPathValue, error) {
	fp, err := ParseGeometry_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Geometry field path value from %s: %v", valueStr, err)
	}
	return fpv.(Geometry_FieldPathValue), nil
}

func MustParseGeometry_FieldPathValue(pathStr, valueStr string) Geometry_FieldPathValue {
	fpv, err := ParseGeometry_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Geometry_FieldTerminalPathValue struct {
	Geometry_FieldTerminalPath
	value interface{}
}

var _ Geometry_FieldPathValue = (*Geometry_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Geometry' as interface{}
func (fpv *Geometry_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Geometry_FieldTerminalPathValue) AsCenterValue() (*latlng.LatLng, bool) {
	res, ok := fpv.value.(*latlng.LatLng)
	return res, ok
}
func (fpv *Geometry_FieldTerminalPathValue) AsBboxValue() (*BBox, bool) {
	res, ok := fpv.value.(*BBox)
	return res, ok
}
func (fpv *Geometry_FieldTerminalPathValue) AsPolygonValue() (*Polygon, bool) {
	res, ok := fpv.value.(*Polygon)
	return res, ok
}
func (fpv *Geometry_FieldTerminalPathValue) AsPanningValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}

// SetTo stores value for selected field for object Geometry
func (fpv *Geometry_FieldTerminalPathValue) SetTo(target **Geometry) {
	if *target == nil {
		*target = new(Geometry)
	}
	switch fpv.selector {
	case Geometry_FieldPathSelectorCenter:
		(*target).Center = fpv.value.(*latlng.LatLng)
	case Geometry_FieldPathSelectorBbox:
		(*target).Bbox = fpv.value.(*BBox)
	case Geometry_FieldPathSelectorPolygon:
		(*target).Polygon = fpv.value.(*Polygon)
	case Geometry_FieldPathSelectorPanning:
		(*target).Panning = fpv.value.(float64)
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fpv.selector))
	}
}

func (fpv *Geometry_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Geometry)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Geometry_FieldTerminalPathValue' with the value under path in 'Geometry'.
func (fpv *Geometry_FieldTerminalPathValue) CompareWith(source *Geometry) (int, bool) {
	switch fpv.selector {
	case Geometry_FieldPathSelectorCenter:
		return 0, false
	case Geometry_FieldPathSelectorBbox:
		return 0, false
	case Geometry_FieldPathSelectorPolygon:
		return 0, false
	case Geometry_FieldPathSelectorPanning:
		leftValue := fpv.value.(float64)
		rightValue := source.GetPanning()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fpv.selector))
	}
}

func (fpv *Geometry_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Geometry))
}

type Geometry_FieldSubPathValue struct {
	Geometry_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ Geometry_FieldPathValue = (*Geometry_FieldSubPathValue)(nil)

func (fpvs *Geometry_FieldSubPathValue) AsBboxPathValue() (BBox_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(BBox_FieldPathValue)
	return res, ok
}
func (fpvs *Geometry_FieldSubPathValue) AsPolygonPathValue() (Polygon_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(Polygon_FieldPathValue)
	return res, ok
}

func (fpvs *Geometry_FieldSubPathValue) SetTo(target **Geometry) {
	if *target == nil {
		*target = new(Geometry)
	}
	switch fpvs.Selector() {
	case Geometry_FieldPathSelectorBbox:
		fpvs.subPathValue.(BBox_FieldPathValue).SetTo(&(*target).Bbox)
	case Geometry_FieldPathSelectorPolygon:
		fpvs.subPathValue.(Polygon_FieldPathValue).SetTo(&(*target).Polygon)
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fpvs.Selector()))
	}
}

func (fpvs *Geometry_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Geometry)
	fpvs.SetTo(&typedObject)
}

func (fpvs *Geometry_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *Geometry_FieldSubPathValue) CompareWith(source *Geometry) (int, bool) {
	switch fpvs.Selector() {
	case Geometry_FieldPathSelectorBbox:
		return fpvs.subPathValue.(BBox_FieldPathValue).CompareWith(source.GetBbox())
	case Geometry_FieldPathSelectorPolygon:
		return fpvs.subPathValue.(Polygon_FieldPathValue).CompareWith(source.GetPolygon())
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fpvs.Selector()))
	}
}

func (fpvs *Geometry_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*Geometry))
}

// Geometry_FieldPathArrayItemValue allows storing single item in Path-specific values for Geometry according to their type
// Present only for array (repeated) types.
type Geometry_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Geometry_FieldPath
	ContainsValue(*Geometry) bool
}

// ParseGeometry_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseGeometry_FieldPathArrayItemValue(pathStr, valueStr string) (Geometry_FieldPathArrayItemValue, error) {
	fp, err := ParseGeometry_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Geometry field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Geometry_FieldPathArrayItemValue), nil
}

func MustParseGeometry_FieldPathArrayItemValue(pathStr, valueStr string) Geometry_FieldPathArrayItemValue {
	fpaiv, err := ParseGeometry_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Geometry_FieldTerminalPathArrayItemValue struct {
	Geometry_FieldTerminalPath
	value interface{}
}

var _ Geometry_FieldPathArrayItemValue = (*Geometry_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Geometry as interface{}
func (fpaiv *Geometry_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *Geometry_FieldTerminalPathArrayItemValue) GetSingle(source *Geometry) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Geometry_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Geometry))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Geometry'
func (fpaiv *Geometry_FieldTerminalPathArrayItemValue) ContainsValue(source *Geometry) bool {
	slice := fpaiv.Geometry_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type Geometry_FieldSubPathArrayItemValue struct {
	Geometry_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *Geometry_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *Geometry_FieldSubPathArrayItemValue) AsBboxPathItemValue() (BBox_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(BBox_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Geometry_FieldSubPathArrayItemValue) AsPolygonPathItemValue() (Polygon_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(Polygon_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'Geometry'
func (fpaivs *Geometry_FieldSubPathArrayItemValue) ContainsValue(source *Geometry) bool {
	switch fpaivs.Selector() {
	case Geometry_FieldPathSelectorBbox:
		return fpaivs.subPathItemValue.(BBox_FieldPathArrayItemValue).ContainsValue(source.GetBbox())
	case Geometry_FieldPathSelectorPolygon:
		return fpaivs.subPathItemValue.(Polygon_FieldPathArrayItemValue).ContainsValue(source.GetPolygon())
	default:
		panic(fmt.Sprintf("Invalid selector for Geometry: %d", fpaivs.Selector()))
	}
}

// Geometry_FieldPathArrayOfValues allows storing slice of values for Geometry fields according to their type
type Geometry_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Geometry_FieldPath
}

func ParseGeometry_FieldPathArrayOfValues(pathStr, valuesStr string) (Geometry_FieldPathArrayOfValues, error) {
	fp, err := ParseGeometry_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Geometry field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Geometry_FieldPathArrayOfValues), nil
}

func MustParseGeometry_FieldPathArrayOfValues(pathStr, valuesStr string) Geometry_FieldPathArrayOfValues {
	fpaov, err := ParseGeometry_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Geometry_FieldTerminalPathArrayOfValues struct {
	Geometry_FieldTerminalPath
	values interface{}
}

var _ Geometry_FieldPathArrayOfValues = (*Geometry_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Geometry_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Geometry_FieldPathSelectorCenter:
		for _, v := range fpaov.values.([]*latlng.LatLng) {
			values = append(values, v)
		}
	case Geometry_FieldPathSelectorBbox:
		for _, v := range fpaov.values.([]*BBox) {
			values = append(values, v)
		}
	case Geometry_FieldPathSelectorPolygon:
		for _, v := range fpaov.values.([]*Polygon) {
			values = append(values, v)
		}
	case Geometry_FieldPathSelectorPanning:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Geometry_FieldTerminalPathArrayOfValues) AsCenterArrayOfValues() ([]*latlng.LatLng, bool) {
	res, ok := fpaov.values.([]*latlng.LatLng)
	return res, ok
}
func (fpaov *Geometry_FieldTerminalPathArrayOfValues) AsBboxArrayOfValues() ([]*BBox, bool) {
	res, ok := fpaov.values.([]*BBox)
	return res, ok
}
func (fpaov *Geometry_FieldTerminalPathArrayOfValues) AsPolygonArrayOfValues() ([]*Polygon, bool) {
	res, ok := fpaov.values.([]*Polygon)
	return res, ok
}
func (fpaov *Geometry_FieldTerminalPathArrayOfValues) AsPanningArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}

type Geometry_FieldSubPathArrayOfValues struct {
	Geometry_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ Geometry_FieldPathArrayOfValues = (*Geometry_FieldSubPathArrayOfValues)(nil)

func (fpsaov *Geometry_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *Geometry_FieldSubPathArrayOfValues) AsBboxPathArrayOfValues() (BBox_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(BBox_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Geometry_FieldSubPathArrayOfValues) AsPolygonPathArrayOfValues() (Polygon_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(Polygon_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type StreetLocation_FieldPath interface {
	gotenobject.FieldPath
	Selector() StreetLocation_FieldPathSelector
	Get(source *StreetLocation) []interface{}
	GetSingle(source *StreetLocation) (interface{}, bool)
	ClearValue(item *StreetLocation)

	// Those methods build corresponding StreetLocation_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) StreetLocation_FieldPathValue
	WithIArrayOfValues(values interface{}) StreetLocation_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) StreetLocation_FieldPathArrayItemValue
}

type StreetLocation_FieldPathSelector int32

const (
	StreetLocation_FieldPathSelectorStreetAddress     StreetLocation_FieldPathSelector = 0
	StreetLocation_FieldPathSelectorStreetCoordinates StreetLocation_FieldPathSelector = 1
)

func (s StreetLocation_FieldPathSelector) String() string {
	switch s {
	case StreetLocation_FieldPathSelectorStreetAddress:
		return "street_address"
	case StreetLocation_FieldPathSelectorStreetCoordinates:
		return "street_coordinates"
	default:
		panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", s))
	}
}

func BuildStreetLocation_FieldPath(fp gotenobject.RawFieldPath) (StreetLocation_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object StreetLocation")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "street_address", "streetAddress", "street-address":
			return &StreetLocation_FieldTerminalPath{selector: StreetLocation_FieldPathSelectorStreetAddress}, nil
		case "street_coordinates", "streetCoordinates", "street-coordinates":
			return &StreetLocation_FieldTerminalPath{selector: StreetLocation_FieldPathSelectorStreetCoordinates}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object StreetLocation", fp)
}

func ParseStreetLocation_FieldPath(rawField string) (StreetLocation_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildStreetLocation_FieldPath(fp)
}

func MustParseStreetLocation_FieldPath(rawField string) StreetLocation_FieldPath {
	fp, err := ParseStreetLocation_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type StreetLocation_FieldTerminalPath struct {
	selector StreetLocation_FieldPathSelector
}

var _ StreetLocation_FieldPath = (*StreetLocation_FieldTerminalPath)(nil)

func (fp *StreetLocation_FieldTerminalPath) Selector() StreetLocation_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *StreetLocation_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *StreetLocation_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source StreetLocation
func (fp *StreetLocation_FieldTerminalPath) Get(source *StreetLocation) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case StreetLocation_FieldPathSelectorStreetAddress:
			values = append(values, source.StreetAddress)
		case StreetLocation_FieldPathSelectorStreetCoordinates:
			if source.StreetCoordinates != nil {
				values = append(values, source.StreetCoordinates)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", fp.selector))
		}
	}
	return
}

func (fp *StreetLocation_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*StreetLocation))
}

// GetSingle returns value pointed by specific field of from source StreetLocation
func (fp *StreetLocation_FieldTerminalPath) GetSingle(source *StreetLocation) (interface{}, bool) {
	switch fp.selector {
	case StreetLocation_FieldPathSelectorStreetAddress:
		return source.GetStreetAddress(), source != nil
	case StreetLocation_FieldPathSelectorStreetCoordinates:
		res := source.GetStreetCoordinates()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", fp.selector))
	}
}

func (fp *StreetLocation_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*StreetLocation))
}

// GetDefault returns a default value of the field type
func (fp *StreetLocation_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case StreetLocation_FieldPathSelectorStreetAddress:
		return ""
	case StreetLocation_FieldPathSelectorStreetCoordinates:
		return (*latlng.LatLng)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", fp.selector))
	}
}

func (fp *StreetLocation_FieldTerminalPath) ClearValue(item *StreetLocation) {
	if item != nil {
		switch fp.selector {
		case StreetLocation_FieldPathSelectorStreetAddress:
			item.StreetAddress = ""
		case StreetLocation_FieldPathSelectorStreetCoordinates:
			item.StreetCoordinates = nil
		default:
			panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", fp.selector))
		}
	}
}

func (fp *StreetLocation_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*StreetLocation))
}

// IsLeaf - whether field path is holds simple value
func (fp *StreetLocation_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == StreetLocation_FieldPathSelectorStreetAddress ||
		fp.selector == StreetLocation_FieldPathSelectorStreetCoordinates
}

func (fp *StreetLocation_FieldTerminalPath) WithIValue(value interface{}) StreetLocation_FieldPathValue {
	switch fp.selector {
	case StreetLocation_FieldPathSelectorStreetAddress:
		return &StreetLocation_FieldTerminalPathValue{StreetLocation_FieldTerminalPath: *fp, value: value.(string)}
	case StreetLocation_FieldPathSelectorStreetCoordinates:
		return &StreetLocation_FieldTerminalPathValue{StreetLocation_FieldTerminalPath: *fp, value: value.(*latlng.LatLng)}
	default:
		panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", fp.selector))
	}
}

func (fp *StreetLocation_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *StreetLocation_FieldTerminalPath) WithIArrayOfValues(values interface{}) StreetLocation_FieldPathArrayOfValues {
	fpaov := &StreetLocation_FieldTerminalPathArrayOfValues{StreetLocation_FieldTerminalPath: *fp}
	switch fp.selector {
	case StreetLocation_FieldPathSelectorStreetAddress:
		return &StreetLocation_FieldTerminalPathArrayOfValues{StreetLocation_FieldTerminalPath: *fp, values: values.([]string)}
	case StreetLocation_FieldPathSelectorStreetCoordinates:
		return &StreetLocation_FieldTerminalPathArrayOfValues{StreetLocation_FieldTerminalPath: *fp, values: values.([]*latlng.LatLng)}
	default:
		panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", fp.selector))
	}
	return fpaov
}

func (fp *StreetLocation_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *StreetLocation_FieldTerminalPath) WithIArrayItemValue(value interface{}) StreetLocation_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", fp.selector))
	}
}

func (fp *StreetLocation_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// StreetLocation_FieldPathValue allows storing values for StreetLocation fields according to their type
type StreetLocation_FieldPathValue interface {
	StreetLocation_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **StreetLocation)
	CompareWith(*StreetLocation) (cmp int, comparable bool)
}

func ParseStreetLocation_FieldPathValue(pathStr, valueStr string) (StreetLocation_FieldPathValue, error) {
	fp, err := ParseStreetLocation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing StreetLocation field path value from %s: %v", valueStr, err)
	}
	return fpv.(StreetLocation_FieldPathValue), nil
}

func MustParseStreetLocation_FieldPathValue(pathStr, valueStr string) StreetLocation_FieldPathValue {
	fpv, err := ParseStreetLocation_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type StreetLocation_FieldTerminalPathValue struct {
	StreetLocation_FieldTerminalPath
	value interface{}
}

var _ StreetLocation_FieldPathValue = (*StreetLocation_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'StreetLocation' as interface{}
func (fpv *StreetLocation_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *StreetLocation_FieldTerminalPathValue) AsStreetAddressValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *StreetLocation_FieldTerminalPathValue) AsStreetCoordinatesValue() (*latlng.LatLng, bool) {
	res, ok := fpv.value.(*latlng.LatLng)
	return res, ok
}

// SetTo stores value for selected field for object StreetLocation
func (fpv *StreetLocation_FieldTerminalPathValue) SetTo(target **StreetLocation) {
	if *target == nil {
		*target = new(StreetLocation)
	}
	switch fpv.selector {
	case StreetLocation_FieldPathSelectorStreetAddress:
		(*target).StreetAddress = fpv.value.(string)
	case StreetLocation_FieldPathSelectorStreetCoordinates:
		(*target).StreetCoordinates = fpv.value.(*latlng.LatLng)
	default:
		panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", fpv.selector))
	}
}

func (fpv *StreetLocation_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*StreetLocation)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'StreetLocation_FieldTerminalPathValue' with the value under path in 'StreetLocation'.
func (fpv *StreetLocation_FieldTerminalPathValue) CompareWith(source *StreetLocation) (int, bool) {
	switch fpv.selector {
	case StreetLocation_FieldPathSelectorStreetAddress:
		leftValue := fpv.value.(string)
		rightValue := source.GetStreetAddress()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case StreetLocation_FieldPathSelectorStreetCoordinates:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for StreetLocation: %d", fpv.selector))
	}
}

func (fpv *StreetLocation_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*StreetLocation))
}

// StreetLocation_FieldPathArrayItemValue allows storing single item in Path-specific values for StreetLocation according to their type
// Present only for array (repeated) types.
type StreetLocation_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	StreetLocation_FieldPath
	ContainsValue(*StreetLocation) bool
}

// ParseStreetLocation_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseStreetLocation_FieldPathArrayItemValue(pathStr, valueStr string) (StreetLocation_FieldPathArrayItemValue, error) {
	fp, err := ParseStreetLocation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing StreetLocation field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(StreetLocation_FieldPathArrayItemValue), nil
}

func MustParseStreetLocation_FieldPathArrayItemValue(pathStr, valueStr string) StreetLocation_FieldPathArrayItemValue {
	fpaiv, err := ParseStreetLocation_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type StreetLocation_FieldTerminalPathArrayItemValue struct {
	StreetLocation_FieldTerminalPath
	value interface{}
}

var _ StreetLocation_FieldPathArrayItemValue = (*StreetLocation_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object StreetLocation as interface{}
func (fpaiv *StreetLocation_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *StreetLocation_FieldTerminalPathArrayItemValue) GetSingle(source *StreetLocation) (interface{}, bool) {
	return nil, false
}

func (fpaiv *StreetLocation_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*StreetLocation))
}

// Contains returns a boolean indicating if value that is being held is present in given 'StreetLocation'
func (fpaiv *StreetLocation_FieldTerminalPathArrayItemValue) ContainsValue(source *StreetLocation) bool {
	slice := fpaiv.StreetLocation_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// StreetLocation_FieldPathArrayOfValues allows storing slice of values for StreetLocation fields according to their type
type StreetLocation_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	StreetLocation_FieldPath
}

func ParseStreetLocation_FieldPathArrayOfValues(pathStr, valuesStr string) (StreetLocation_FieldPathArrayOfValues, error) {
	fp, err := ParseStreetLocation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing StreetLocation field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(StreetLocation_FieldPathArrayOfValues), nil
}

func MustParseStreetLocation_FieldPathArrayOfValues(pathStr, valuesStr string) StreetLocation_FieldPathArrayOfValues {
	fpaov, err := ParseStreetLocation_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type StreetLocation_FieldTerminalPathArrayOfValues struct {
	StreetLocation_FieldTerminalPath
	values interface{}
}

var _ StreetLocation_FieldPathArrayOfValues = (*StreetLocation_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *StreetLocation_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case StreetLocation_FieldPathSelectorStreetAddress:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case StreetLocation_FieldPathSelectorStreetCoordinates:
		for _, v := range fpaov.values.([]*latlng.LatLng) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *StreetLocation_FieldTerminalPathArrayOfValues) AsStreetAddressArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *StreetLocation_FieldTerminalPathArrayOfValues) AsStreetCoordinatesArrayOfValues() ([]*latlng.LatLng, bool) {
	res, ok := fpaov.values.([]*latlng.LatLng)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type VendorMapping_FieldPath interface {
	gotenobject.FieldPath
	Selector() VendorMapping_FieldPathSelector
	Get(source *VendorMapping) []interface{}
	GetSingle(source *VendorMapping) (interface{}, bool)
	ClearValue(item *VendorMapping)

	// Those methods build corresponding VendorMapping_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) VendorMapping_FieldPathValue
	WithIArrayOfValues(values interface{}) VendorMapping_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) VendorMapping_FieldPathArrayItemValue
}

type VendorMapping_FieldPathSelector int32

const (
	VendorMapping_FieldPathSelectorVendor VendorMapping_FieldPathSelector = 0
	VendorMapping_FieldPathSelectorId     VendorMapping_FieldPathSelector = 1
)

func (s VendorMapping_FieldPathSelector) String() string {
	switch s {
	case VendorMapping_FieldPathSelectorVendor:
		return "vendor"
	case VendorMapping_FieldPathSelectorId:
		return "id"
	default:
		panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", s))
	}
}

func BuildVendorMapping_FieldPath(fp gotenobject.RawFieldPath) (VendorMapping_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object VendorMapping")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "vendor":
			return &VendorMapping_FieldTerminalPath{selector: VendorMapping_FieldPathSelectorVendor}, nil
		case "id":
			return &VendorMapping_FieldTerminalPath{selector: VendorMapping_FieldPathSelectorId}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object VendorMapping", fp)
}

func ParseVendorMapping_FieldPath(rawField string) (VendorMapping_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildVendorMapping_FieldPath(fp)
}

func MustParseVendorMapping_FieldPath(rawField string) VendorMapping_FieldPath {
	fp, err := ParseVendorMapping_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type VendorMapping_FieldTerminalPath struct {
	selector VendorMapping_FieldPathSelector
}

var _ VendorMapping_FieldPath = (*VendorMapping_FieldTerminalPath)(nil)

func (fp *VendorMapping_FieldTerminalPath) Selector() VendorMapping_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *VendorMapping_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *VendorMapping_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source VendorMapping
func (fp *VendorMapping_FieldTerminalPath) Get(source *VendorMapping) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case VendorMapping_FieldPathSelectorVendor:
			values = append(values, source.Vendor)
		case VendorMapping_FieldPathSelectorId:
			values = append(values, source.Id)
		default:
			panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", fp.selector))
		}
	}
	return
}

func (fp *VendorMapping_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*VendorMapping))
}

// GetSingle returns value pointed by specific field of from source VendorMapping
func (fp *VendorMapping_FieldTerminalPath) GetSingle(source *VendorMapping) (interface{}, bool) {
	switch fp.selector {
	case VendorMapping_FieldPathSelectorVendor:
		return source.GetVendor(), source != nil
	case VendorMapping_FieldPathSelectorId:
		return source.GetId(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", fp.selector))
	}
}

func (fp *VendorMapping_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*VendorMapping))
}

// GetDefault returns a default value of the field type
func (fp *VendorMapping_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case VendorMapping_FieldPathSelectorVendor:
		return Vendor_VENDOR_UNSPECIFIED
	case VendorMapping_FieldPathSelectorId:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", fp.selector))
	}
}

func (fp *VendorMapping_FieldTerminalPath) ClearValue(item *VendorMapping) {
	if item != nil {
		switch fp.selector {
		case VendorMapping_FieldPathSelectorVendor:
			item.Vendor = Vendor_VENDOR_UNSPECIFIED
		case VendorMapping_FieldPathSelectorId:
			item.Id = ""
		default:
			panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", fp.selector))
		}
	}
}

func (fp *VendorMapping_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*VendorMapping))
}

// IsLeaf - whether field path is holds simple value
func (fp *VendorMapping_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == VendorMapping_FieldPathSelectorVendor ||
		fp.selector == VendorMapping_FieldPathSelectorId
}

func (fp *VendorMapping_FieldTerminalPath) WithIValue(value interface{}) VendorMapping_FieldPathValue {
	switch fp.selector {
	case VendorMapping_FieldPathSelectorVendor:
		return &VendorMapping_FieldTerminalPathValue{VendorMapping_FieldTerminalPath: *fp, value: value.(Vendor)}
	case VendorMapping_FieldPathSelectorId:
		return &VendorMapping_FieldTerminalPathValue{VendorMapping_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", fp.selector))
	}
}

func (fp *VendorMapping_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *VendorMapping_FieldTerminalPath) WithIArrayOfValues(values interface{}) VendorMapping_FieldPathArrayOfValues {
	fpaov := &VendorMapping_FieldTerminalPathArrayOfValues{VendorMapping_FieldTerminalPath: *fp}
	switch fp.selector {
	case VendorMapping_FieldPathSelectorVendor:
		return &VendorMapping_FieldTerminalPathArrayOfValues{VendorMapping_FieldTerminalPath: *fp, values: values.([]Vendor)}
	case VendorMapping_FieldPathSelectorId:
		return &VendorMapping_FieldTerminalPathArrayOfValues{VendorMapping_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", fp.selector))
	}
	return fpaov
}

func (fp *VendorMapping_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *VendorMapping_FieldTerminalPath) WithIArrayItemValue(value interface{}) VendorMapping_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", fp.selector))
	}
}

func (fp *VendorMapping_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// VendorMapping_FieldPathValue allows storing values for VendorMapping fields according to their type
type VendorMapping_FieldPathValue interface {
	VendorMapping_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **VendorMapping)
	CompareWith(*VendorMapping) (cmp int, comparable bool)
}

func ParseVendorMapping_FieldPathValue(pathStr, valueStr string) (VendorMapping_FieldPathValue, error) {
	fp, err := ParseVendorMapping_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing VendorMapping field path value from %s: %v", valueStr, err)
	}
	return fpv.(VendorMapping_FieldPathValue), nil
}

func MustParseVendorMapping_FieldPathValue(pathStr, valueStr string) VendorMapping_FieldPathValue {
	fpv, err := ParseVendorMapping_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type VendorMapping_FieldTerminalPathValue struct {
	VendorMapping_FieldTerminalPath
	value interface{}
}

var _ VendorMapping_FieldPathValue = (*VendorMapping_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'VendorMapping' as interface{}
func (fpv *VendorMapping_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *VendorMapping_FieldTerminalPathValue) AsVendorValue() (Vendor, bool) {
	res, ok := fpv.value.(Vendor)
	return res, ok
}
func (fpv *VendorMapping_FieldTerminalPathValue) AsIdValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object VendorMapping
func (fpv *VendorMapping_FieldTerminalPathValue) SetTo(target **VendorMapping) {
	if *target == nil {
		*target = new(VendorMapping)
	}
	switch fpv.selector {
	case VendorMapping_FieldPathSelectorVendor:
		(*target).Vendor = fpv.value.(Vendor)
	case VendorMapping_FieldPathSelectorId:
		(*target).Id = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", fpv.selector))
	}
}

func (fpv *VendorMapping_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*VendorMapping)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'VendorMapping_FieldTerminalPathValue' with the value under path in 'VendorMapping'.
func (fpv *VendorMapping_FieldTerminalPathValue) CompareWith(source *VendorMapping) (int, bool) {
	switch fpv.selector {
	case VendorMapping_FieldPathSelectorVendor:
		leftValue := fpv.value.(Vendor)
		rightValue := source.GetVendor()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case VendorMapping_FieldPathSelectorId:
		leftValue := fpv.value.(string)
		rightValue := source.GetId()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for VendorMapping: %d", fpv.selector))
	}
}

func (fpv *VendorMapping_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*VendorMapping))
}

// VendorMapping_FieldPathArrayItemValue allows storing single item in Path-specific values for VendorMapping according to their type
// Present only for array (repeated) types.
type VendorMapping_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	VendorMapping_FieldPath
	ContainsValue(*VendorMapping) bool
}

// ParseVendorMapping_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseVendorMapping_FieldPathArrayItemValue(pathStr, valueStr string) (VendorMapping_FieldPathArrayItemValue, error) {
	fp, err := ParseVendorMapping_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing VendorMapping field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(VendorMapping_FieldPathArrayItemValue), nil
}

func MustParseVendorMapping_FieldPathArrayItemValue(pathStr, valueStr string) VendorMapping_FieldPathArrayItemValue {
	fpaiv, err := ParseVendorMapping_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type VendorMapping_FieldTerminalPathArrayItemValue struct {
	VendorMapping_FieldTerminalPath
	value interface{}
}

var _ VendorMapping_FieldPathArrayItemValue = (*VendorMapping_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object VendorMapping as interface{}
func (fpaiv *VendorMapping_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *VendorMapping_FieldTerminalPathArrayItemValue) GetSingle(source *VendorMapping) (interface{}, bool) {
	return nil, false
}

func (fpaiv *VendorMapping_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*VendorMapping))
}

// Contains returns a boolean indicating if value that is being held is present in given 'VendorMapping'
func (fpaiv *VendorMapping_FieldTerminalPathArrayItemValue) ContainsValue(source *VendorMapping) bool {
	slice := fpaiv.VendorMapping_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// VendorMapping_FieldPathArrayOfValues allows storing slice of values for VendorMapping fields according to their type
type VendorMapping_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	VendorMapping_FieldPath
}

func ParseVendorMapping_FieldPathArrayOfValues(pathStr, valuesStr string) (VendorMapping_FieldPathArrayOfValues, error) {
	fp, err := ParseVendorMapping_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing VendorMapping field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(VendorMapping_FieldPathArrayOfValues), nil
}

func MustParseVendorMapping_FieldPathArrayOfValues(pathStr, valuesStr string) VendorMapping_FieldPathArrayOfValues {
	fpaov, err := ParseVendorMapping_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type VendorMapping_FieldTerminalPathArrayOfValues struct {
	VendorMapping_FieldTerminalPath
	values interface{}
}

var _ VendorMapping_FieldPathArrayOfValues = (*VendorMapping_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *VendorMapping_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case VendorMapping_FieldPathSelectorVendor:
		for _, v := range fpaov.values.([]Vendor) {
			values = append(values, v)
		}
	case VendorMapping_FieldPathSelectorId:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *VendorMapping_FieldTerminalPathArrayOfValues) AsVendorArrayOfValues() ([]Vendor, bool) {
	res, ok := fpaov.values.([]Vendor)
	return res, ok
}
func (fpaov *VendorMapping_FieldTerminalPathArrayOfValues) AsIdArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Point_FieldPath interface {
	gotenobject.FieldPath
	Selector() Point_FieldPathSelector
	Get(source *Point) []interface{}
	GetSingle(source *Point) (interface{}, bool)
	ClearValue(item *Point)

	// Those methods build corresponding Point_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Point_FieldPathValue
	WithIArrayOfValues(values interface{}) Point_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Point_FieldPathArrayItemValue
}

type Point_FieldPathSelector int32

const (
	Point_FieldPathSelectorX Point_FieldPathSelector = 0
	Point_FieldPathSelectorY Point_FieldPathSelector = 1
)

func (s Point_FieldPathSelector) String() string {
	switch s {
	case Point_FieldPathSelectorX:
		return "x"
	case Point_FieldPathSelectorY:
		return "y"
	default:
		panic(fmt.Sprintf("Invalid selector for Point: %d", s))
	}
}

func BuildPoint_FieldPath(fp gotenobject.RawFieldPath) (Point_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Point")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "x":
			return &Point_FieldTerminalPath{selector: Point_FieldPathSelectorX}, nil
		case "y":
			return &Point_FieldTerminalPath{selector: Point_FieldPathSelectorY}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Point", fp)
}

func ParsePoint_FieldPath(rawField string) (Point_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildPoint_FieldPath(fp)
}

func MustParsePoint_FieldPath(rawField string) Point_FieldPath {
	fp, err := ParsePoint_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Point_FieldTerminalPath struct {
	selector Point_FieldPathSelector
}

var _ Point_FieldPath = (*Point_FieldTerminalPath)(nil)

func (fp *Point_FieldTerminalPath) Selector() Point_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Point_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Point_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Point
func (fp *Point_FieldTerminalPath) Get(source *Point) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Point_FieldPathSelectorX:
			values = append(values, source.X)
		case Point_FieldPathSelectorY:
			values = append(values, source.Y)
		default:
			panic(fmt.Sprintf("Invalid selector for Point: %d", fp.selector))
		}
	}
	return
}

func (fp *Point_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Point))
}

// GetSingle returns value pointed by specific field of from source Point
func (fp *Point_FieldTerminalPath) GetSingle(source *Point) (interface{}, bool) {
	switch fp.selector {
	case Point_FieldPathSelectorX:
		return source.GetX(), source != nil
	case Point_FieldPathSelectorY:
		return source.GetY(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Point: %d", fp.selector))
	}
}

func (fp *Point_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Point))
}

// GetDefault returns a default value of the field type
func (fp *Point_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Point_FieldPathSelectorX:
		return float64(0)
	case Point_FieldPathSelectorY:
		return float64(0)
	default:
		panic(fmt.Sprintf("Invalid selector for Point: %d", fp.selector))
	}
}

func (fp *Point_FieldTerminalPath) ClearValue(item *Point) {
	if item != nil {
		switch fp.selector {
		case Point_FieldPathSelectorX:
			item.X = float64(0)
		case Point_FieldPathSelectorY:
			item.Y = float64(0)
		default:
			panic(fmt.Sprintf("Invalid selector for Point: %d", fp.selector))
		}
	}
}

func (fp *Point_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Point))
}

// IsLeaf - whether field path is holds simple value
func (fp *Point_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Point_FieldPathSelectorX ||
		fp.selector == Point_FieldPathSelectorY
}

func (fp *Point_FieldTerminalPath) WithIValue(value interface{}) Point_FieldPathValue {
	switch fp.selector {
	case Point_FieldPathSelectorX:
		return &Point_FieldTerminalPathValue{Point_FieldTerminalPath: *fp, value: value.(float64)}
	case Point_FieldPathSelectorY:
		return &Point_FieldTerminalPathValue{Point_FieldTerminalPath: *fp, value: value.(float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Point: %d", fp.selector))
	}
}

func (fp *Point_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Point_FieldTerminalPath) WithIArrayOfValues(values interface{}) Point_FieldPathArrayOfValues {
	fpaov := &Point_FieldTerminalPathArrayOfValues{Point_FieldTerminalPath: *fp}
	switch fp.selector {
	case Point_FieldPathSelectorX:
		return &Point_FieldTerminalPathArrayOfValues{Point_FieldTerminalPath: *fp, values: values.([]float64)}
	case Point_FieldPathSelectorY:
		return &Point_FieldTerminalPathArrayOfValues{Point_FieldTerminalPath: *fp, values: values.([]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Point: %d", fp.selector))
	}
	return fpaov
}

func (fp *Point_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Point_FieldTerminalPath) WithIArrayItemValue(value interface{}) Point_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Point: %d", fp.selector))
	}
}

func (fp *Point_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Point_FieldPathValue allows storing values for Point fields according to their type
type Point_FieldPathValue interface {
	Point_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Point)
	CompareWith(*Point) (cmp int, comparable bool)
}

func ParsePoint_FieldPathValue(pathStr, valueStr string) (Point_FieldPathValue, error) {
	fp, err := ParsePoint_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Point field path value from %s: %v", valueStr, err)
	}
	return fpv.(Point_FieldPathValue), nil
}

func MustParsePoint_FieldPathValue(pathStr, valueStr string) Point_FieldPathValue {
	fpv, err := ParsePoint_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Point_FieldTerminalPathValue struct {
	Point_FieldTerminalPath
	value interface{}
}

var _ Point_FieldPathValue = (*Point_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Point' as interface{}
func (fpv *Point_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Point_FieldTerminalPathValue) AsXValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}
func (fpv *Point_FieldTerminalPathValue) AsYValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}

// SetTo stores value for selected field for object Point
func (fpv *Point_FieldTerminalPathValue) SetTo(target **Point) {
	if *target == nil {
		*target = new(Point)
	}
	switch fpv.selector {
	case Point_FieldPathSelectorX:
		(*target).X = fpv.value.(float64)
	case Point_FieldPathSelectorY:
		(*target).Y = fpv.value.(float64)
	default:
		panic(fmt.Sprintf("Invalid selector for Point: %d", fpv.selector))
	}
}

func (fpv *Point_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Point)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Point_FieldTerminalPathValue' with the value under path in 'Point'.
func (fpv *Point_FieldTerminalPathValue) CompareWith(source *Point) (int, bool) {
	switch fpv.selector {
	case Point_FieldPathSelectorX:
		leftValue := fpv.value.(float64)
		rightValue := source.GetX()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Point_FieldPathSelectorY:
		leftValue := fpv.value.(float64)
		rightValue := source.GetY()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Point: %d", fpv.selector))
	}
}

func (fpv *Point_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Point))
}

// Point_FieldPathArrayItemValue allows storing single item in Path-specific values for Point according to their type
// Present only for array (repeated) types.
type Point_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Point_FieldPath
	ContainsValue(*Point) bool
}

// ParsePoint_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParsePoint_FieldPathArrayItemValue(pathStr, valueStr string) (Point_FieldPathArrayItemValue, error) {
	fp, err := ParsePoint_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Point field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Point_FieldPathArrayItemValue), nil
}

func MustParsePoint_FieldPathArrayItemValue(pathStr, valueStr string) Point_FieldPathArrayItemValue {
	fpaiv, err := ParsePoint_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Point_FieldTerminalPathArrayItemValue struct {
	Point_FieldTerminalPath
	value interface{}
}

var _ Point_FieldPathArrayItemValue = (*Point_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Point as interface{}
func (fpaiv *Point_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *Point_FieldTerminalPathArrayItemValue) GetSingle(source *Point) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Point_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Point))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Point'
func (fpaiv *Point_FieldTerminalPathArrayItemValue) ContainsValue(source *Point) bool {
	slice := fpaiv.Point_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Point_FieldPathArrayOfValues allows storing slice of values for Point fields according to their type
type Point_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Point_FieldPath
}

func ParsePoint_FieldPathArrayOfValues(pathStr, valuesStr string) (Point_FieldPathArrayOfValues, error) {
	fp, err := ParsePoint_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Point field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Point_FieldPathArrayOfValues), nil
}

func MustParsePoint_FieldPathArrayOfValues(pathStr, valuesStr string) Point_FieldPathArrayOfValues {
	fpaov, err := ParsePoint_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Point_FieldTerminalPathArrayOfValues struct {
	Point_FieldTerminalPath
	values interface{}
}

var _ Point_FieldPathArrayOfValues = (*Point_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Point_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Point_FieldPathSelectorX:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	case Point_FieldPathSelectorY:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Point_FieldTerminalPathArrayOfValues) AsXArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}
func (fpaov *Point_FieldTerminalPathArrayOfValues) AsYArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ReferencePoint_FieldPath interface {
	gotenobject.FieldPath
	Selector() ReferencePoint_FieldPathSelector
	Get(source *ReferencePoint) []interface{}
	GetSingle(source *ReferencePoint) (interface{}, bool)
	ClearValue(item *ReferencePoint)

	// Those methods build corresponding ReferencePoint_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ReferencePoint_FieldPathValue
	WithIArrayOfValues(values interface{}) ReferencePoint_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ReferencePoint_FieldPathArrayItemValue
}

type ReferencePoint_FieldPathSelector int32

const (
	ReferencePoint_FieldPathSelectorPoint  ReferencePoint_FieldPathSelector = 0
	ReferencePoint_FieldPathSelectorLatLng ReferencePoint_FieldPathSelector = 1
)

func (s ReferencePoint_FieldPathSelector) String() string {
	switch s {
	case ReferencePoint_FieldPathSelectorPoint:
		return "point"
	case ReferencePoint_FieldPathSelectorLatLng:
		return "lat_lng"
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", s))
	}
}

func BuildReferencePoint_FieldPath(fp gotenobject.RawFieldPath) (ReferencePoint_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ReferencePoint")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "point":
			return &ReferencePoint_FieldTerminalPath{selector: ReferencePoint_FieldPathSelectorPoint}, nil
		case "lat_lng", "latLng", "lat-lng":
			return &ReferencePoint_FieldTerminalPath{selector: ReferencePoint_FieldPathSelectorLatLng}, nil
		}
	} else {
		switch fp[0] {
		case "point":
			if subpath, err := BuildPoint_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ReferencePoint_FieldSubPath{selector: ReferencePoint_FieldPathSelectorPoint, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ReferencePoint", fp)
}

func ParseReferencePoint_FieldPath(rawField string) (ReferencePoint_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildReferencePoint_FieldPath(fp)
}

func MustParseReferencePoint_FieldPath(rawField string) ReferencePoint_FieldPath {
	fp, err := ParseReferencePoint_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ReferencePoint_FieldTerminalPath struct {
	selector ReferencePoint_FieldPathSelector
}

var _ ReferencePoint_FieldPath = (*ReferencePoint_FieldTerminalPath)(nil)

func (fp *ReferencePoint_FieldTerminalPath) Selector() ReferencePoint_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ReferencePoint_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ReferencePoint_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ReferencePoint
func (fp *ReferencePoint_FieldTerminalPath) Get(source *ReferencePoint) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ReferencePoint_FieldPathSelectorPoint:
			if source.Point != nil {
				values = append(values, source.Point)
			}
		case ReferencePoint_FieldPathSelectorLatLng:
			if source.LatLng != nil {
				values = append(values, source.LatLng)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fp.selector))
		}
	}
	return
}

func (fp *ReferencePoint_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ReferencePoint))
}

// GetSingle returns value pointed by specific field of from source ReferencePoint
func (fp *ReferencePoint_FieldTerminalPath) GetSingle(source *ReferencePoint) (interface{}, bool) {
	switch fp.selector {
	case ReferencePoint_FieldPathSelectorPoint:
		res := source.GetPoint()
		return res, res != nil
	case ReferencePoint_FieldPathSelectorLatLng:
		res := source.GetLatLng()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fp.selector))
	}
}

func (fp *ReferencePoint_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ReferencePoint))
}

// GetDefault returns a default value of the field type
func (fp *ReferencePoint_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ReferencePoint_FieldPathSelectorPoint:
		return (*Point)(nil)
	case ReferencePoint_FieldPathSelectorLatLng:
		return (*latlng.LatLng)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fp.selector))
	}
}

func (fp *ReferencePoint_FieldTerminalPath) ClearValue(item *ReferencePoint) {
	if item != nil {
		switch fp.selector {
		case ReferencePoint_FieldPathSelectorPoint:
			item.Point = nil
		case ReferencePoint_FieldPathSelectorLatLng:
			item.LatLng = nil
		default:
			panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fp.selector))
		}
	}
}

func (fp *ReferencePoint_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ReferencePoint))
}

// IsLeaf - whether field path is holds simple value
func (fp *ReferencePoint_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ReferencePoint_FieldPathSelectorLatLng
}

func (fp *ReferencePoint_FieldTerminalPath) WithIValue(value interface{}) ReferencePoint_FieldPathValue {
	switch fp.selector {
	case ReferencePoint_FieldPathSelectorPoint:
		return &ReferencePoint_FieldTerminalPathValue{ReferencePoint_FieldTerminalPath: *fp, value: value.(*Point)}
	case ReferencePoint_FieldPathSelectorLatLng:
		return &ReferencePoint_FieldTerminalPathValue{ReferencePoint_FieldTerminalPath: *fp, value: value.(*latlng.LatLng)}
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fp.selector))
	}
}

func (fp *ReferencePoint_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ReferencePoint_FieldTerminalPath) WithIArrayOfValues(values interface{}) ReferencePoint_FieldPathArrayOfValues {
	fpaov := &ReferencePoint_FieldTerminalPathArrayOfValues{ReferencePoint_FieldTerminalPath: *fp}
	switch fp.selector {
	case ReferencePoint_FieldPathSelectorPoint:
		return &ReferencePoint_FieldTerminalPathArrayOfValues{ReferencePoint_FieldTerminalPath: *fp, values: values.([]*Point)}
	case ReferencePoint_FieldPathSelectorLatLng:
		return &ReferencePoint_FieldTerminalPathArrayOfValues{ReferencePoint_FieldTerminalPath: *fp, values: values.([]*latlng.LatLng)}
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fp.selector))
	}
	return fpaov
}

func (fp *ReferencePoint_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ReferencePoint_FieldTerminalPath) WithIArrayItemValue(value interface{}) ReferencePoint_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fp.selector))
	}
}

func (fp *ReferencePoint_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type ReferencePoint_FieldSubPath struct {
	selector ReferencePoint_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ ReferencePoint_FieldPath = (*ReferencePoint_FieldSubPath)(nil)

func (fps *ReferencePoint_FieldSubPath) Selector() ReferencePoint_FieldPathSelector {
	return fps.selector
}
func (fps *ReferencePoint_FieldSubPath) AsPointSubPath() (Point_FieldPath, bool) {
	res, ok := fps.subPath.(Point_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *ReferencePoint_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *ReferencePoint_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source ReferencePoint
func (fps *ReferencePoint_FieldSubPath) Get(source *ReferencePoint) (values []interface{}) {
	if asPointFieldPath, ok := fps.AsPointSubPath(); ok {
		values = append(values, asPointFieldPath.Get(source.GetPoint())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fps.selector))
	}
	return
}

func (fps *ReferencePoint_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*ReferencePoint))
}

// GetSingle returns value of selected field from source ReferencePoint
func (fps *ReferencePoint_FieldSubPath) GetSingle(source *ReferencePoint) (interface{}, bool) {
	switch fps.selector {
	case ReferencePoint_FieldPathSelectorPoint:
		if source.GetPoint() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetPoint())
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fps.selector))
	}
}

func (fps *ReferencePoint_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*ReferencePoint))
}

// GetDefault returns a default value of the field type
func (fps *ReferencePoint_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *ReferencePoint_FieldSubPath) ClearValue(item *ReferencePoint) {
	if item != nil {
		switch fps.selector {
		case ReferencePoint_FieldPathSelectorPoint:
			fps.subPath.ClearValueRaw(item.Point)
		default:
			panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fps.selector))
		}
	}
}

func (fps *ReferencePoint_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*ReferencePoint))
}

// IsLeaf - whether field path is holds simple value
func (fps *ReferencePoint_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *ReferencePoint_FieldSubPath) WithIValue(value interface{}) ReferencePoint_FieldPathValue {
	return &ReferencePoint_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *ReferencePoint_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *ReferencePoint_FieldSubPath) WithIArrayOfValues(values interface{}) ReferencePoint_FieldPathArrayOfValues {
	return &ReferencePoint_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *ReferencePoint_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *ReferencePoint_FieldSubPath) WithIArrayItemValue(value interface{}) ReferencePoint_FieldPathArrayItemValue {
	return &ReferencePoint_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *ReferencePoint_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// ReferencePoint_FieldPathValue allows storing values for ReferencePoint fields according to their type
type ReferencePoint_FieldPathValue interface {
	ReferencePoint_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ReferencePoint)
	CompareWith(*ReferencePoint) (cmp int, comparable bool)
}

func ParseReferencePoint_FieldPathValue(pathStr, valueStr string) (ReferencePoint_FieldPathValue, error) {
	fp, err := ParseReferencePoint_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ReferencePoint field path value from %s: %v", valueStr, err)
	}
	return fpv.(ReferencePoint_FieldPathValue), nil
}

func MustParseReferencePoint_FieldPathValue(pathStr, valueStr string) ReferencePoint_FieldPathValue {
	fpv, err := ParseReferencePoint_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ReferencePoint_FieldTerminalPathValue struct {
	ReferencePoint_FieldTerminalPath
	value interface{}
}

var _ ReferencePoint_FieldPathValue = (*ReferencePoint_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ReferencePoint' as interface{}
func (fpv *ReferencePoint_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ReferencePoint_FieldTerminalPathValue) AsPointValue() (*Point, bool) {
	res, ok := fpv.value.(*Point)
	return res, ok
}
func (fpv *ReferencePoint_FieldTerminalPathValue) AsLatLngValue() (*latlng.LatLng, bool) {
	res, ok := fpv.value.(*latlng.LatLng)
	return res, ok
}

// SetTo stores value for selected field for object ReferencePoint
func (fpv *ReferencePoint_FieldTerminalPathValue) SetTo(target **ReferencePoint) {
	if *target == nil {
		*target = new(ReferencePoint)
	}
	switch fpv.selector {
	case ReferencePoint_FieldPathSelectorPoint:
		(*target).Point = fpv.value.(*Point)
	case ReferencePoint_FieldPathSelectorLatLng:
		(*target).LatLng = fpv.value.(*latlng.LatLng)
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fpv.selector))
	}
}

func (fpv *ReferencePoint_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ReferencePoint)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ReferencePoint_FieldTerminalPathValue' with the value under path in 'ReferencePoint'.
func (fpv *ReferencePoint_FieldTerminalPathValue) CompareWith(source *ReferencePoint) (int, bool) {
	switch fpv.selector {
	case ReferencePoint_FieldPathSelectorPoint:
		return 0, false
	case ReferencePoint_FieldPathSelectorLatLng:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fpv.selector))
	}
}

func (fpv *ReferencePoint_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ReferencePoint))
}

type ReferencePoint_FieldSubPathValue struct {
	ReferencePoint_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ ReferencePoint_FieldPathValue = (*ReferencePoint_FieldSubPathValue)(nil)

func (fpvs *ReferencePoint_FieldSubPathValue) AsPointPathValue() (Point_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(Point_FieldPathValue)
	return res, ok
}

func (fpvs *ReferencePoint_FieldSubPathValue) SetTo(target **ReferencePoint) {
	if *target == nil {
		*target = new(ReferencePoint)
	}
	switch fpvs.Selector() {
	case ReferencePoint_FieldPathSelectorPoint:
		fpvs.subPathValue.(Point_FieldPathValue).SetTo(&(*target).Point)
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fpvs.Selector()))
	}
}

func (fpvs *ReferencePoint_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ReferencePoint)
	fpvs.SetTo(&typedObject)
}

func (fpvs *ReferencePoint_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *ReferencePoint_FieldSubPathValue) CompareWith(source *ReferencePoint) (int, bool) {
	switch fpvs.Selector() {
	case ReferencePoint_FieldPathSelectorPoint:
		return fpvs.subPathValue.(Point_FieldPathValue).CompareWith(source.GetPoint())
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fpvs.Selector()))
	}
}

func (fpvs *ReferencePoint_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*ReferencePoint))
}

// ReferencePoint_FieldPathArrayItemValue allows storing single item in Path-specific values for ReferencePoint according to their type
// Present only for array (repeated) types.
type ReferencePoint_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ReferencePoint_FieldPath
	ContainsValue(*ReferencePoint) bool
}

// ParseReferencePoint_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseReferencePoint_FieldPathArrayItemValue(pathStr, valueStr string) (ReferencePoint_FieldPathArrayItemValue, error) {
	fp, err := ParseReferencePoint_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ReferencePoint field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ReferencePoint_FieldPathArrayItemValue), nil
}

func MustParseReferencePoint_FieldPathArrayItemValue(pathStr, valueStr string) ReferencePoint_FieldPathArrayItemValue {
	fpaiv, err := ParseReferencePoint_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ReferencePoint_FieldTerminalPathArrayItemValue struct {
	ReferencePoint_FieldTerminalPath
	value interface{}
}

var _ ReferencePoint_FieldPathArrayItemValue = (*ReferencePoint_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ReferencePoint as interface{}
func (fpaiv *ReferencePoint_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ReferencePoint_FieldTerminalPathArrayItemValue) GetSingle(source *ReferencePoint) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ReferencePoint_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ReferencePoint))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ReferencePoint'
func (fpaiv *ReferencePoint_FieldTerminalPathArrayItemValue) ContainsValue(source *ReferencePoint) bool {
	slice := fpaiv.ReferencePoint_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type ReferencePoint_FieldSubPathArrayItemValue struct {
	ReferencePoint_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *ReferencePoint_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *ReferencePoint_FieldSubPathArrayItemValue) AsPointPathItemValue() (Point_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(Point_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ReferencePoint'
func (fpaivs *ReferencePoint_FieldSubPathArrayItemValue) ContainsValue(source *ReferencePoint) bool {
	switch fpaivs.Selector() {
	case ReferencePoint_FieldPathSelectorPoint:
		return fpaivs.subPathItemValue.(Point_FieldPathArrayItemValue).ContainsValue(source.GetPoint())
	default:
		panic(fmt.Sprintf("Invalid selector for ReferencePoint: %d", fpaivs.Selector()))
	}
}

// ReferencePoint_FieldPathArrayOfValues allows storing slice of values for ReferencePoint fields according to their type
type ReferencePoint_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ReferencePoint_FieldPath
}

func ParseReferencePoint_FieldPathArrayOfValues(pathStr, valuesStr string) (ReferencePoint_FieldPathArrayOfValues, error) {
	fp, err := ParseReferencePoint_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ReferencePoint field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ReferencePoint_FieldPathArrayOfValues), nil
}

func MustParseReferencePoint_FieldPathArrayOfValues(pathStr, valuesStr string) ReferencePoint_FieldPathArrayOfValues {
	fpaov, err := ParseReferencePoint_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ReferencePoint_FieldTerminalPathArrayOfValues struct {
	ReferencePoint_FieldTerminalPath
	values interface{}
}

var _ ReferencePoint_FieldPathArrayOfValues = (*ReferencePoint_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ReferencePoint_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ReferencePoint_FieldPathSelectorPoint:
		for _, v := range fpaov.values.([]*Point) {
			values = append(values, v)
		}
	case ReferencePoint_FieldPathSelectorLatLng:
		for _, v := range fpaov.values.([]*latlng.LatLng) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ReferencePoint_FieldTerminalPathArrayOfValues) AsPointArrayOfValues() ([]*Point, bool) {
	res, ok := fpaov.values.([]*Point)
	return res, ok
}
func (fpaov *ReferencePoint_FieldTerminalPathArrayOfValues) AsLatLngArrayOfValues() ([]*latlng.LatLng, bool) {
	res, ok := fpaov.values.([]*latlng.LatLng)
	return res, ok
}

type ReferencePoint_FieldSubPathArrayOfValues struct {
	ReferencePoint_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ ReferencePoint_FieldPathArrayOfValues = (*ReferencePoint_FieldSubPathArrayOfValues)(nil)

func (fpsaov *ReferencePoint_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *ReferencePoint_FieldSubPathArrayOfValues) AsPointPathArrayOfValues() (Point_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(Point_FieldPathArrayOfValues)
	return res, ok
}
