// Code generated by protoc-gen-goten-object
// File: workplace/proto/v1alpha2/floor_service.proto
// DO NOT EDIT!!!

package floor_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	building "github.com/cloudwan/workplace-sdk/resources/v1alpha2/building"
	floor "github.com/cloudwan/workplace-sdk/resources/v1alpha2/floor"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
	_ = &building.Building{}
	_ = &floor.Floor{}
)

type GetFloorRequest_FieldMask struct {
	Paths []GetFloorRequest_FieldPath
}

func FullGetFloorRequest_FieldMask() *GetFloorRequest_FieldMask {
	res := &GetFloorRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetFloorRequest_FieldTerminalPath{selector: GetFloorRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetFloorRequest_FieldTerminalPath{selector: GetFloorRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetFloorRequest_FieldTerminalPath{selector: GetFloorRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetFloorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetFloorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetFloorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetFloorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetFloorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetFloorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetFloorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetFloorRequest_FieldPath(raw)
	})
}

func (fieldMask *GetFloorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetFloorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetFloorRequest_FieldMask) Subtract(other *GetFloorRequest_FieldMask) *GetFloorRequest_FieldMask {
	result := &GetFloorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetFloorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetFloorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetFloorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetFloorRequest_FieldMask) FilterInputFields() *GetFloorRequest_FieldMask {
	result := &GetFloorRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetFloorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetFloorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetFloorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetFloorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetFloorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetFloorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetFloorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetFloorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetFloorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetFloorRequest_FieldMask) AppendPath(path GetFloorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetFloorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetFloorRequest_FieldPath))
}

func (fieldMask *GetFloorRequest_FieldMask) GetPaths() []GetFloorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetFloorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetFloorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetFloorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetFloorRequest_FieldMask) Set(target, source *GetFloorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetFloorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetFloorRequest), source.(*GetFloorRequest))
}

func (fieldMask *GetFloorRequest_FieldMask) Project(source *GetFloorRequest) *GetFloorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetFloorRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetFloorRequest_FieldTerminalPath:
			switch tp.selector {
			case GetFloorRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetFloorRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetFloorRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetFloorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetFloorRequest))
}

func (fieldMask *GetFloorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetFloorsRequest_FieldMask struct {
	Paths []BatchGetFloorsRequest_FieldPath
}

func FullBatchGetFloorsRequest_FieldMask() *BatchGetFloorsRequest_FieldMask {
	res := &BatchGetFloorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetFloorsRequest_FieldTerminalPath{selector: BatchGetFloorsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &BatchGetFloorsRequest_FieldTerminalPath{selector: BatchGetFloorsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetFloorsRequest_FieldTerminalPath{selector: BatchGetFloorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetFloorsRequest_FieldTerminalPath{selector: BatchGetFloorsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetFloorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetFloorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetFloorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetFloorsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetFloorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) Subtract(other *BatchGetFloorsRequest_FieldMask) *BatchGetFloorsRequest_FieldMask {
	result := &BatchGetFloorsRequest_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetFloorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetFloorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetFloorsRequest_FieldMask) FilterInputFields() *BatchGetFloorsRequest_FieldMask {
	result := &BatchGetFloorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetFloorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetFloorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetFloorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetFloorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetFloorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) AppendPath(path BatchGetFloorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetFloorsRequest_FieldPath))
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) GetPaths() []BatchGetFloorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetFloorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) Set(target, source *BatchGetFloorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetFloorsRequest), source.(*BatchGetFloorsRequest))
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) Project(source *BatchGetFloorsRequest) *BatchGetFloorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetFloorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetFloorsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetFloorsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case BatchGetFloorsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetFloorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetFloorsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetFloorsRequest))
}

func (fieldMask *BatchGetFloorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetFloorsResponse_FieldMask struct {
	Paths []BatchGetFloorsResponse_FieldPath
}

func FullBatchGetFloorsResponse_FieldMask() *BatchGetFloorsResponse_FieldMask {
	res := &BatchGetFloorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetFloorsResponse_FieldTerminalPath{selector: BatchGetFloorsResponse_FieldPathSelectorFloors})
	res.Paths = append(res.Paths, &BatchGetFloorsResponse_FieldTerminalPath{selector: BatchGetFloorsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetFloorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetFloorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetFloorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetFloorsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetFloorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) Subtract(other *BatchGetFloorsResponse_FieldMask) *BatchGetFloorsResponse_FieldMask {
	result := &BatchGetFloorsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetFloorsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetFloorsResponse_FieldPathSelectorFloors: &floor.Floor_FieldMask{},
	}
	mySubMasks := map[BatchGetFloorsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetFloorsResponse_FieldPathSelectorFloors: &floor.Floor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetFloorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetFloorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetFloorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetFloorsResponse_FieldPathSelectorFloors:
						mySubMasks[BatchGetFloorsResponse_FieldPathSelectorFloors] = floor.FullFloor_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetFloorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetFloorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetFloorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetFloorsResponse_FieldMask) FilterInputFields() *BatchGetFloorsResponse_FieldMask {
	result := &BatchGetFloorsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetFloorsResponse_FieldPathSelectorFloors:
			if _, ok := path.(*BatchGetFloorsResponse_FieldTerminalPath); ok {
				for _, subpath := range floor.FullFloor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetFloorsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetFloorsResponse_FieldSubPath); ok {
				selectedMask := &floor.Floor_FieldMask{
					Paths: []floor.Floor_FieldPath{sub.subPath.(floor.Floor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetFloorsResponse_FieldSubPath{selector: BatchGetFloorsResponse_FieldPathSelectorFloors, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetFloorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetFloorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetFloorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetFloorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetFloorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) AppendPath(path BatchGetFloorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetFloorsResponse_FieldPath))
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) GetPaths() []BatchGetFloorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetFloorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) Set(target, source *BatchGetFloorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetFloorsResponse), source.(*BatchGetFloorsResponse))
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) Project(source *BatchGetFloorsResponse) *BatchGetFloorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetFloorsResponse{}
	floorsMask := &floor.Floor_FieldMask{}
	wholeFloorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetFloorsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetFloorsResponse_FieldPathSelectorFloors:
				result.Floors = source.Floors
				wholeFloorsAccepted = true
			case BatchGetFloorsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetFloorsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetFloorsResponse_FieldPathSelectorFloors:
				floorsMask.AppendPath(tp.subPath.(floor.Floor_FieldPath))
			}
		}
	}
	if wholeFloorsAccepted == false && len(floorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetFloors() {
			result.Floors = append(result.Floors, floorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetFloorsResponse))
}

func (fieldMask *BatchGetFloorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListFloorsRequest_FieldMask struct {
	Paths []ListFloorsRequest_FieldPath
}

func FullListFloorsRequest_FieldMask() *ListFloorsRequest_FieldMask {
	res := &ListFloorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListFloorsRequest_FieldTerminalPath{selector: ListFloorsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListFloorsRequest_FieldTerminalPath{selector: ListFloorsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListFloorsRequest_FieldTerminalPath{selector: ListFloorsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListFloorsRequest_FieldTerminalPath{selector: ListFloorsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListFloorsRequest_FieldTerminalPath{selector: ListFloorsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListFloorsRequest_FieldTerminalPath{selector: ListFloorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListFloorsRequest_FieldTerminalPath{selector: ListFloorsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListFloorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListFloorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListFloorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListFloorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListFloorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListFloorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListFloorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListFloorsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListFloorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListFloorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListFloorsRequest_FieldMask) Subtract(other *ListFloorsRequest_FieldMask) *ListFloorsRequest_FieldMask {
	result := &ListFloorsRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListFloorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListFloorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListFloorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListFloorsRequest_FieldMask) FilterInputFields() *ListFloorsRequest_FieldMask {
	result := &ListFloorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListFloorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListFloorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListFloorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListFloorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListFloorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListFloorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListFloorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListFloorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListFloorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListFloorsRequest_FieldMask) AppendPath(path ListFloorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListFloorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListFloorsRequest_FieldPath))
}

func (fieldMask *ListFloorsRequest_FieldMask) GetPaths() []ListFloorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListFloorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListFloorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListFloorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListFloorsRequest_FieldMask) Set(target, source *ListFloorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListFloorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListFloorsRequest), source.(*ListFloorsRequest))
}

func (fieldMask *ListFloorsRequest_FieldMask) Project(source *ListFloorsRequest) *ListFloorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListFloorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListFloorsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListFloorsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListFloorsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListFloorsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListFloorsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListFloorsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListFloorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListFloorsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListFloorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListFloorsRequest))
}

func (fieldMask *ListFloorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListFloorsResponse_FieldMask struct {
	Paths []ListFloorsResponse_FieldPath
}

func FullListFloorsResponse_FieldMask() *ListFloorsResponse_FieldMask {
	res := &ListFloorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListFloorsResponse_FieldTerminalPath{selector: ListFloorsResponse_FieldPathSelectorFloors})
	res.Paths = append(res.Paths, &ListFloorsResponse_FieldTerminalPath{selector: ListFloorsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListFloorsResponse_FieldTerminalPath{selector: ListFloorsResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListFloorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListFloorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListFloorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListFloorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListFloorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListFloorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListFloorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListFloorsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListFloorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListFloorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListFloorsResponse_FieldMask) Subtract(other *ListFloorsResponse_FieldMask) *ListFloorsResponse_FieldMask {
	result := &ListFloorsResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListFloorsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListFloorsResponse_FieldPathSelectorFloors: &floor.Floor_FieldMask{},
	}
	mySubMasks := map[ListFloorsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListFloorsResponse_FieldPathSelectorFloors: &floor.Floor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListFloorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListFloorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListFloorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListFloorsResponse_FieldPathSelectorFloors:
						mySubMasks[ListFloorsResponse_FieldPathSelectorFloors] = floor.FullFloor_FieldMask()
					}
				} else if tp, ok := path.(*ListFloorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListFloorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListFloorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListFloorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListFloorsResponse_FieldMask) FilterInputFields() *ListFloorsResponse_FieldMask {
	result := &ListFloorsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListFloorsResponse_FieldPathSelectorFloors:
			if _, ok := path.(*ListFloorsResponse_FieldTerminalPath); ok {
				for _, subpath := range floor.FullFloor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListFloorsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListFloorsResponse_FieldSubPath); ok {
				selectedMask := &floor.Floor_FieldMask{
					Paths: []floor.Floor_FieldPath{sub.subPath.(floor.Floor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListFloorsResponse_FieldSubPath{selector: ListFloorsResponse_FieldPathSelectorFloors, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListFloorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListFloorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListFloorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListFloorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListFloorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListFloorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListFloorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListFloorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListFloorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListFloorsResponse_FieldMask) AppendPath(path ListFloorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListFloorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListFloorsResponse_FieldPath))
}

func (fieldMask *ListFloorsResponse_FieldMask) GetPaths() []ListFloorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListFloorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListFloorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListFloorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListFloorsResponse_FieldMask) Set(target, source *ListFloorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListFloorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListFloorsResponse), source.(*ListFloorsResponse))
}

func (fieldMask *ListFloorsResponse_FieldMask) Project(source *ListFloorsResponse) *ListFloorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListFloorsResponse{}
	floorsMask := &floor.Floor_FieldMask{}
	wholeFloorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListFloorsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListFloorsResponse_FieldPathSelectorFloors:
				result.Floors = source.Floors
				wholeFloorsAccepted = true
			case ListFloorsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListFloorsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListFloorsResponse_FieldSubPath:
			switch tp.selector {
			case ListFloorsResponse_FieldPathSelectorFloors:
				floorsMask.AppendPath(tp.subPath.(floor.Floor_FieldPath))
			}
		}
	}
	if wholeFloorsAccepted == false && len(floorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetFloors() {
			result.Floors = append(result.Floors, floorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListFloorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListFloorsResponse))
}

func (fieldMask *ListFloorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchFloorRequest_FieldMask struct {
	Paths []WatchFloorRequest_FieldPath
}

func FullWatchFloorRequest_FieldMask() *WatchFloorRequest_FieldMask {
	res := &WatchFloorRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchFloorRequest_FieldTerminalPath{selector: WatchFloorRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchFloorRequest_FieldTerminalPath{selector: WatchFloorRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchFloorRequest_FieldTerminalPath{selector: WatchFloorRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchFloorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchFloorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchFloorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchFloorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchFloorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchFloorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchFloorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchFloorRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchFloorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchFloorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchFloorRequest_FieldMask) Subtract(other *WatchFloorRequest_FieldMask) *WatchFloorRequest_FieldMask {
	result := &WatchFloorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchFloorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchFloorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchFloorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchFloorRequest_FieldMask) FilterInputFields() *WatchFloorRequest_FieldMask {
	result := &WatchFloorRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchFloorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchFloorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchFloorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchFloorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchFloorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchFloorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchFloorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchFloorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorRequest_FieldMask) AppendPath(path WatchFloorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchFloorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchFloorRequest_FieldPath))
}

func (fieldMask *WatchFloorRequest_FieldMask) GetPaths() []WatchFloorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchFloorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchFloorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchFloorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchFloorRequest_FieldMask) Set(target, source *WatchFloorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchFloorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchFloorRequest), source.(*WatchFloorRequest))
}

func (fieldMask *WatchFloorRequest_FieldMask) Project(source *WatchFloorRequest) *WatchFloorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchFloorRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchFloorRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchFloorRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchFloorRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchFloorRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchFloorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchFloorRequest))
}

func (fieldMask *WatchFloorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchFloorResponse_FieldMask struct {
	Paths []WatchFloorResponse_FieldPath
}

func FullWatchFloorResponse_FieldMask() *WatchFloorResponse_FieldMask {
	res := &WatchFloorResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchFloorResponse_FieldTerminalPath{selector: WatchFloorResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchFloorResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchFloorResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchFloorResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchFloorResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchFloorResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchFloorResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchFloorResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchFloorResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchFloorResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchFloorResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchFloorResponse_FieldMask) Subtract(other *WatchFloorResponse_FieldMask) *WatchFloorResponse_FieldMask {
	result := &WatchFloorResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchFloorResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchFloorResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchFloorResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchFloorResponse_FieldMask) FilterInputFields() *WatchFloorResponse_FieldMask {
	result := &WatchFloorResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchFloorResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchFloorResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchFloorResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchFloorResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchFloorResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchFloorResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchFloorResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchFloorResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorResponse_FieldMask) AppendPath(path WatchFloorResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchFloorResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchFloorResponse_FieldPath))
}

func (fieldMask *WatchFloorResponse_FieldMask) GetPaths() []WatchFloorResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchFloorResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchFloorResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchFloorResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchFloorResponse_FieldMask) Set(target, source *WatchFloorResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchFloorResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchFloorResponse), source.(*WatchFloorResponse))
}

func (fieldMask *WatchFloorResponse_FieldMask) Project(source *WatchFloorResponse) *WatchFloorResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchFloorResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchFloorResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchFloorResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchFloorResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchFloorResponse))
}

func (fieldMask *WatchFloorResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchFloorsRequest_FieldMask struct {
	Paths []WatchFloorsRequest_FieldPath
}

func FullWatchFloorsRequest_FieldMask() *WatchFloorsRequest_FieldMask {
	res := &WatchFloorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchFloorsRequest_FieldTerminalPath{selector: WatchFloorsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchFloorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchFloorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchFloorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchFloorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchFloorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchFloorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchFloorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchFloorsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchFloorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchFloorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchFloorsRequest_FieldMask) Subtract(other *WatchFloorsRequest_FieldMask) *WatchFloorsRequest_FieldMask {
	result := &WatchFloorsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchFloorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchFloorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchFloorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchFloorsRequest_FieldMask) FilterInputFields() *WatchFloorsRequest_FieldMask {
	result := &WatchFloorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchFloorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchFloorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchFloorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchFloorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchFloorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchFloorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchFloorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchFloorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorsRequest_FieldMask) AppendPath(path WatchFloorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchFloorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchFloorsRequest_FieldPath))
}

func (fieldMask *WatchFloorsRequest_FieldMask) GetPaths() []WatchFloorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchFloorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchFloorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchFloorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchFloorsRequest_FieldMask) Set(target, source *WatchFloorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchFloorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchFloorsRequest), source.(*WatchFloorsRequest))
}

func (fieldMask *WatchFloorsRequest_FieldMask) Project(source *WatchFloorsRequest) *WatchFloorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchFloorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchFloorsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchFloorsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchFloorsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchFloorsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchFloorsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchFloorsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchFloorsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchFloorsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchFloorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchFloorsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchFloorsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchFloorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchFloorsRequest))
}

func (fieldMask *WatchFloorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchFloorsResponse_FieldMask struct {
	Paths []WatchFloorsResponse_FieldPath
}

func FullWatchFloorsResponse_FieldMask() *WatchFloorsResponse_FieldMask {
	res := &WatchFloorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchFloorsResponse_FieldTerminalPath{selector: WatchFloorsResponse_FieldPathSelectorFloorChanges})
	res.Paths = append(res.Paths, &WatchFloorsResponse_FieldTerminalPath{selector: WatchFloorsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchFloorsResponse_FieldTerminalPath{selector: WatchFloorsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchFloorsResponse_FieldTerminalPath{selector: WatchFloorsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchFloorsResponse_FieldTerminalPath{selector: WatchFloorsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchFloorsResponse_FieldTerminalPath{selector: WatchFloorsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchFloorsResponse_FieldTerminalPath{selector: WatchFloorsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchFloorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchFloorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchFloorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchFloorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchFloorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchFloorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchFloorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchFloorsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchFloorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchFloorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchFloorsResponse_FieldMask) Subtract(other *WatchFloorsResponse_FieldMask) *WatchFloorsResponse_FieldMask {
	result := &WatchFloorsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchFloorsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchFloorsResponse_FieldPathSelectorPageTokenChange: &WatchFloorsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchFloorsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchFloorsResponse_FieldPathSelectorPageTokenChange: &WatchFloorsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchFloorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchFloorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchFloorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchFloorsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchFloorsResponse_FieldPathSelectorPageTokenChange] = FullWatchFloorsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchFloorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchFloorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchFloorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchFloorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchFloorsResponse_FieldMask) FilterInputFields() *WatchFloorsResponse_FieldMask {
	result := &WatchFloorsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchFloorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchFloorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchFloorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchFloorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchFloorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchFloorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchFloorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchFloorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorsResponse_FieldMask) AppendPath(path WatchFloorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchFloorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchFloorsResponse_FieldPath))
}

func (fieldMask *WatchFloorsResponse_FieldMask) GetPaths() []WatchFloorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchFloorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchFloorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchFloorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchFloorsResponse_FieldMask) Set(target, source *WatchFloorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchFloorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchFloorsResponse), source.(*WatchFloorsResponse))
}

func (fieldMask *WatchFloorsResponse_FieldMask) Project(source *WatchFloorsResponse) *WatchFloorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchFloorsResponse{}
	pageTokenChangeMask := &WatchFloorsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchFloorsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchFloorsResponse_FieldPathSelectorFloorChanges:
				result.FloorChanges = source.FloorChanges
			case WatchFloorsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchFloorsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchFloorsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchFloorsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchFloorsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchFloorsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchFloorsResponse_FieldSubPath:
			switch tp.selector {
			case WatchFloorsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchFloorsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchFloorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchFloorsResponse))
}

func (fieldMask *WatchFloorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchFloorsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchFloorsResponsePageTokenChange_FieldPath
}

func FullWatchFloorsResponse_PageTokenChange_FieldMask() *WatchFloorsResponse_PageTokenChange_FieldMask {
	res := &WatchFloorsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchFloorsResponsePageTokenChange_FieldTerminalPath{selector: WatchFloorsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchFloorsResponsePageTokenChange_FieldTerminalPath{selector: WatchFloorsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchFloorsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchFloorsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchFloorsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) Subtract(other *WatchFloorsResponse_PageTokenChange_FieldMask) *WatchFloorsResponse_PageTokenChange_FieldMask {
	result := &WatchFloorsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchFloorsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchFloorsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchFloorsResponse_PageTokenChange_FieldMask {
	result := &WatchFloorsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchFloorsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchFloorsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchFloorsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchFloorsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) AppendPath(path WatchFloorsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchFloorsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) GetPaths() []WatchFloorsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchFloorsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) Set(target, source *WatchFloorsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchFloorsResponse_PageTokenChange), source.(*WatchFloorsResponse_PageTokenChange))
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) Project(source *WatchFloorsResponse_PageTokenChange) *WatchFloorsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchFloorsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchFloorsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchFloorsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchFloorsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchFloorsResponse_PageTokenChange))
}

func (fieldMask *WatchFloorsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateFloorRequest_FieldMask struct {
	Paths []CreateFloorRequest_FieldPath
}

func FullCreateFloorRequest_FieldMask() *CreateFloorRequest_FieldMask {
	res := &CreateFloorRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateFloorRequest_FieldTerminalPath{selector: CreateFloorRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateFloorRequest_FieldTerminalPath{selector: CreateFloorRequest_FieldPathSelectorFloor})
	return res
}

func (fieldMask *CreateFloorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateFloorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateFloorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateFloorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateFloorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateFloorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateFloorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateFloorRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateFloorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateFloorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateFloorRequest_FieldMask) Subtract(other *CreateFloorRequest_FieldMask) *CreateFloorRequest_FieldMask {
	result := &CreateFloorRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateFloorRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateFloorRequest_FieldPathSelectorFloor: &floor.Floor_FieldMask{},
	}
	mySubMasks := map[CreateFloorRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateFloorRequest_FieldPathSelectorFloor: &floor.Floor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateFloorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateFloorRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateFloorRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateFloorRequest_FieldPathSelectorFloor:
						mySubMasks[CreateFloorRequest_FieldPathSelectorFloor] = floor.FullFloor_FieldMask()
					}
				} else if tp, ok := path.(*CreateFloorRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateFloorRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateFloorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateFloorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateFloorRequest_FieldMask) FilterInputFields() *CreateFloorRequest_FieldMask {
	result := &CreateFloorRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateFloorRequest_FieldPathSelectorFloor:
			if _, ok := path.(*CreateFloorRequest_FieldTerminalPath); ok {
				for _, subpath := range floor.FullFloor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateFloorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateFloorRequest_FieldSubPath); ok {
				selectedMask := &floor.Floor_FieldMask{
					Paths: []floor.Floor_FieldPath{sub.subPath.(floor.Floor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateFloorRequest_FieldSubPath{selector: CreateFloorRequest_FieldPathSelectorFloor, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateFloorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateFloorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateFloorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateFloorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateFloorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateFloorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateFloorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateFloorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateFloorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateFloorRequest_FieldMask) AppendPath(path CreateFloorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateFloorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateFloorRequest_FieldPath))
}

func (fieldMask *CreateFloorRequest_FieldMask) GetPaths() []CreateFloorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateFloorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateFloorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateFloorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateFloorRequest_FieldMask) Set(target, source *CreateFloorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateFloorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateFloorRequest), source.(*CreateFloorRequest))
}

func (fieldMask *CreateFloorRequest_FieldMask) Project(source *CreateFloorRequest) *CreateFloorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateFloorRequest{}
	floorMask := &floor.Floor_FieldMask{}
	wholeFloorAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateFloorRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateFloorRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateFloorRequest_FieldPathSelectorFloor:
				result.Floor = source.Floor
				wholeFloorAccepted = true
			}
		case *CreateFloorRequest_FieldSubPath:
			switch tp.selector {
			case CreateFloorRequest_FieldPathSelectorFloor:
				floorMask.AppendPath(tp.subPath.(floor.Floor_FieldPath))
			}
		}
	}
	if wholeFloorAccepted == false && len(floorMask.Paths) > 0 {
		result.Floor = floorMask.Project(source.GetFloor())
	}
	return result
}

func (fieldMask *CreateFloorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateFloorRequest))
}

func (fieldMask *CreateFloorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateFloorRequest_FieldMask struct {
	Paths []UpdateFloorRequest_FieldPath
}

func FullUpdateFloorRequest_FieldMask() *UpdateFloorRequest_FieldMask {
	res := &UpdateFloorRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateFloorRequest_FieldTerminalPath{selector: UpdateFloorRequest_FieldPathSelectorFloor})
	res.Paths = append(res.Paths, &UpdateFloorRequest_FieldTerminalPath{selector: UpdateFloorRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateFloorRequest_FieldTerminalPath{selector: UpdateFloorRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateFloorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateFloorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateFloorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateFloorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateFloorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateFloorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateFloorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateFloorRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateFloorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateFloorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateFloorRequest_FieldMask) Subtract(other *UpdateFloorRequest_FieldMask) *UpdateFloorRequest_FieldMask {
	result := &UpdateFloorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateFloorRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateFloorRequest_FieldPathSelectorFloor: &floor.Floor_FieldMask{},
		UpdateFloorRequest_FieldPathSelectorCas:   &UpdateFloorRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateFloorRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateFloorRequest_FieldPathSelectorFloor: &floor.Floor_FieldMask{},
		UpdateFloorRequest_FieldPathSelectorCas:   &UpdateFloorRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateFloorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateFloorRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateFloorRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateFloorRequest_FieldPathSelectorFloor:
						mySubMasks[UpdateFloorRequest_FieldPathSelectorFloor] = floor.FullFloor_FieldMask()
					case UpdateFloorRequest_FieldPathSelectorCas:
						mySubMasks[UpdateFloorRequest_FieldPathSelectorCas] = FullUpdateFloorRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateFloorRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateFloorRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateFloorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateFloorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateFloorRequest_FieldMask) FilterInputFields() *UpdateFloorRequest_FieldMask {
	result := &UpdateFloorRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateFloorRequest_FieldPathSelectorFloor:
			if _, ok := path.(*UpdateFloorRequest_FieldTerminalPath); ok {
				for _, subpath := range floor.FullFloor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateFloorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateFloorRequest_FieldSubPath); ok {
				selectedMask := &floor.Floor_FieldMask{
					Paths: []floor.Floor_FieldPath{sub.subPath.(floor.Floor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateFloorRequest_FieldSubPath{selector: UpdateFloorRequest_FieldPathSelectorFloor, subPath: allowedPath})
				}
			}
		case UpdateFloorRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateFloorRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateFloorRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateFloorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateFloorRequest_FieldSubPath); ok {
				selectedMask := &UpdateFloorRequest_CAS_FieldMask{
					Paths: []UpdateFloorRequestCAS_FieldPath{sub.subPath.(UpdateFloorRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateFloorRequest_FieldSubPath{selector: UpdateFloorRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateFloorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateFloorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateFloorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateFloorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateFloorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateFloorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateFloorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateFloorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateFloorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateFloorRequest_FieldMask) AppendPath(path UpdateFloorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateFloorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateFloorRequest_FieldPath))
}

func (fieldMask *UpdateFloorRequest_FieldMask) GetPaths() []UpdateFloorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateFloorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateFloorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateFloorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateFloorRequest_FieldMask) Set(target, source *UpdateFloorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateFloorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateFloorRequest), source.(*UpdateFloorRequest))
}

func (fieldMask *UpdateFloorRequest_FieldMask) Project(source *UpdateFloorRequest) *UpdateFloorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateFloorRequest{}
	floorMask := &floor.Floor_FieldMask{}
	wholeFloorAccepted := false
	casMask := &UpdateFloorRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateFloorRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateFloorRequest_FieldPathSelectorFloor:
				result.Floor = source.Floor
				wholeFloorAccepted = true
			case UpdateFloorRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateFloorRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateFloorRequest_FieldSubPath:
			switch tp.selector {
			case UpdateFloorRequest_FieldPathSelectorFloor:
				floorMask.AppendPath(tp.subPath.(floor.Floor_FieldPath))
			case UpdateFloorRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateFloorRequestCAS_FieldPath))
			}
		}
	}
	if wholeFloorAccepted == false && len(floorMask.Paths) > 0 {
		result.Floor = floorMask.Project(source.GetFloor())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateFloorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateFloorRequest))
}

func (fieldMask *UpdateFloorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateFloorRequest_CAS_FieldMask struct {
	Paths []UpdateFloorRequestCAS_FieldPath
}

func FullUpdateFloorRequest_CAS_FieldMask() *UpdateFloorRequest_CAS_FieldMask {
	res := &UpdateFloorRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateFloorRequestCAS_FieldTerminalPath{selector: UpdateFloorRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateFloorRequestCAS_FieldTerminalPath{selector: UpdateFloorRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateFloorRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateFloorRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateFloorRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateFloorRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) Subtract(other *UpdateFloorRequest_CAS_FieldMask) *UpdateFloorRequest_CAS_FieldMask {
	result := &UpdateFloorRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateFloorRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateFloorRequestCAS_FieldPathSelectorConditionalState: &floor.Floor_FieldMask{},
	}
	mySubMasks := map[UpdateFloorRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateFloorRequestCAS_FieldPathSelectorConditionalState: &floor.Floor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateFloorRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateFloorRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateFloorRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateFloorRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateFloorRequestCAS_FieldPathSelectorConditionalState] = floor.FullFloor_FieldMask()
					}
				} else if tp, ok := path.(*UpdateFloorRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateFloorRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateFloorRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateFloorRequest_CAS_FieldMask) FilterInputFields() *UpdateFloorRequest_CAS_FieldMask {
	result := &UpdateFloorRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateFloorRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateFloorRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range floor.FullFloor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateFloorRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateFloorRequestCAS_FieldSubPath); ok {
				selectedMask := &floor.Floor_FieldMask{
					Paths: []floor.Floor_FieldPath{sub.subPath.(floor.Floor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateFloorRequestCAS_FieldSubPath{selector: UpdateFloorRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateFloorRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateFloorRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateFloorRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateFloorRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateFloorRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) AppendPath(path UpdateFloorRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateFloorRequestCAS_FieldPath))
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) GetPaths() []UpdateFloorRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateFloorRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) Set(target, source *UpdateFloorRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateFloorRequest_CAS), source.(*UpdateFloorRequest_CAS))
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) Project(source *UpdateFloorRequest_CAS) *UpdateFloorRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateFloorRequest_CAS{}
	conditionalStateMask := &floor.Floor_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateFloorRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateFloorRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateFloorRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateFloorRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateFloorRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(floor.Floor_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateFloorRequest_CAS))
}

func (fieldMask *UpdateFloorRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteFloorRequest_FieldMask struct {
	Paths []DeleteFloorRequest_FieldPath
}

func FullDeleteFloorRequest_FieldMask() *DeleteFloorRequest_FieldMask {
	res := &DeleteFloorRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteFloorRequest_FieldTerminalPath{selector: DeleteFloorRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteFloorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteFloorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteFloorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteFloorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteFloorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteFloorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteFloorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteFloorRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteFloorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteFloorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteFloorRequest_FieldMask) Subtract(other *DeleteFloorRequest_FieldMask) *DeleteFloorRequest_FieldMask {
	result := &DeleteFloorRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteFloorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteFloorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteFloorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteFloorRequest_FieldMask) FilterInputFields() *DeleteFloorRequest_FieldMask {
	result := &DeleteFloorRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteFloorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteFloorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteFloorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteFloorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteFloorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteFloorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteFloorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteFloorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteFloorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteFloorRequest_FieldMask) AppendPath(path DeleteFloorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteFloorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteFloorRequest_FieldPath))
}

func (fieldMask *DeleteFloorRequest_FieldMask) GetPaths() []DeleteFloorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteFloorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteFloorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteFloorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteFloorRequest_FieldMask) Set(target, source *DeleteFloorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteFloorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteFloorRequest), source.(*DeleteFloorRequest))
}

func (fieldMask *DeleteFloorRequest_FieldMask) Project(source *DeleteFloorRequest) *DeleteFloorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteFloorRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteFloorRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteFloorRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteFloorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteFloorRequest))
}

func (fieldMask *DeleteFloorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
