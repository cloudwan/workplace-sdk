// Code generated by protoc-gen-goten-object
// File: workplace/proto/v1alpha2/property_service.proto
// DO NOT EDIT!!!

package property_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	area "github.com/cloudwan/workplace-sdk/resources/v1alpha2/area"
	building "github.com/cloudwan/workplace-sdk/resources/v1alpha2/building"
	device "github.com/cloudwan/workplace-sdk/resources/v1alpha2/device"
	floor "github.com/cloudwan/workplace-sdk/resources/v1alpha2/floor"
	property "github.com/cloudwan/workplace-sdk/resources/v1alpha2/property"
	site "github.com/cloudwan/workplace-sdk/resources/v1alpha2/site"
	zone "github.com/cloudwan/workplace-sdk/resources/v1alpha2/zone"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
	_ = &area.Area{}
	_ = &building.Building{}
	_ = &device.Device{}
	_ = &floor.Floor{}
	_ = &property.Property{}
	_ = &site.Site{}
	_ = &zone.Zone{}
)

type GetPropertyRequest_FieldMask struct {
	Paths []GetPropertyRequest_FieldPath
}

func FullGetPropertyRequest_FieldMask() *GetPropertyRequest_FieldMask {
	res := &GetPropertyRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetPropertyRequest_FieldTerminalPath{selector: GetPropertyRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetPropertyRequest_FieldTerminalPath{selector: GetPropertyRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetPropertyRequest_FieldTerminalPath{selector: GetPropertyRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetPropertyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetPropertyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetPropertyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetPropertyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetPropertyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetPropertyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetPropertyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetPropertyRequest_FieldPath(raw)
	})
}

func (fieldMask *GetPropertyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetPropertyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetPropertyRequest_FieldMask) Subtract(other *GetPropertyRequest_FieldMask) *GetPropertyRequest_FieldMask {
	result := &GetPropertyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetPropertyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetPropertyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetPropertyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetPropertyRequest_FieldMask) FilterInputFields() *GetPropertyRequest_FieldMask {
	result := &GetPropertyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetPropertyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetPropertyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetPropertyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetPropertyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetPropertyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetPropertyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetPropertyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetPropertyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetPropertyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetPropertyRequest_FieldMask) AppendPath(path GetPropertyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetPropertyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetPropertyRequest_FieldPath))
}

func (fieldMask *GetPropertyRequest_FieldMask) GetPaths() []GetPropertyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetPropertyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetPropertyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetPropertyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetPropertyRequest_FieldMask) Set(target, source *GetPropertyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetPropertyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetPropertyRequest), source.(*GetPropertyRequest))
}

func (fieldMask *GetPropertyRequest_FieldMask) Project(source *GetPropertyRequest) *GetPropertyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetPropertyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetPropertyRequest_FieldTerminalPath:
			switch tp.selector {
			case GetPropertyRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetPropertyRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetPropertyRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetPropertyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetPropertyRequest))
}

func (fieldMask *GetPropertyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetPropertiesRequest_FieldMask struct {
	Paths []BatchGetPropertiesRequest_FieldPath
}

func FullBatchGetPropertiesRequest_FieldMask() *BatchGetPropertiesRequest_FieldMask {
	res := &BatchGetPropertiesRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetPropertiesRequest_FieldTerminalPath{selector: BatchGetPropertiesRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetPropertiesRequest_FieldTerminalPath{selector: BatchGetPropertiesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetPropertiesRequest_FieldTerminalPath{selector: BatchGetPropertiesRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetPropertiesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetPropertiesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetPropertiesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetPropertiesRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) Subtract(other *BatchGetPropertiesRequest_FieldMask) *BatchGetPropertiesRequest_FieldMask {
	result := &BatchGetPropertiesRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetPropertiesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetPropertiesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetPropertiesRequest_FieldMask) FilterInputFields() *BatchGetPropertiesRequest_FieldMask {
	result := &BatchGetPropertiesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetPropertiesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetPropertiesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetPropertiesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetPropertiesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetPropertiesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) AppendPath(path BatchGetPropertiesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetPropertiesRequest_FieldPath))
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) GetPaths() []BatchGetPropertiesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetPropertiesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) Set(target, source *BatchGetPropertiesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetPropertiesRequest), source.(*BatchGetPropertiesRequest))
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) Project(source *BatchGetPropertiesRequest) *BatchGetPropertiesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetPropertiesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetPropertiesRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetPropertiesRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetPropertiesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetPropertiesRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetPropertiesRequest))
}

func (fieldMask *BatchGetPropertiesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetPropertiesResponse_FieldMask struct {
	Paths []BatchGetPropertiesResponse_FieldPath
}

func FullBatchGetPropertiesResponse_FieldMask() *BatchGetPropertiesResponse_FieldMask {
	res := &BatchGetPropertiesResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetPropertiesResponse_FieldTerminalPath{selector: BatchGetPropertiesResponse_FieldPathSelectorProperties})
	res.Paths = append(res.Paths, &BatchGetPropertiesResponse_FieldTerminalPath{selector: BatchGetPropertiesResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetPropertiesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetPropertiesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetPropertiesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetPropertiesResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) Subtract(other *BatchGetPropertiesResponse_FieldMask) *BatchGetPropertiesResponse_FieldMask {
	result := &BatchGetPropertiesResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetPropertiesResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetPropertiesResponse_FieldPathSelectorProperties: &property.Property_FieldMask{},
	}
	mySubMasks := map[BatchGetPropertiesResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetPropertiesResponse_FieldPathSelectorProperties: &property.Property_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetPropertiesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetPropertiesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetPropertiesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetPropertiesResponse_FieldPathSelectorProperties:
						mySubMasks[BatchGetPropertiesResponse_FieldPathSelectorProperties] = property.FullProperty_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetPropertiesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetPropertiesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetPropertiesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetPropertiesResponse_FieldMask) FilterInputFields() *BatchGetPropertiesResponse_FieldMask {
	result := &BatchGetPropertiesResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetPropertiesResponse_FieldPathSelectorProperties:
			if _, ok := path.(*BatchGetPropertiesResponse_FieldTerminalPath); ok {
				for _, subpath := range property.FullProperty_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetPropertiesResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetPropertiesResponse_FieldSubPath); ok {
				selectedMask := &property.Property_FieldMask{
					Paths: []property.Property_FieldPath{sub.subPath.(property.Property_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetPropertiesResponse_FieldSubPath{selector: BatchGetPropertiesResponse_FieldPathSelectorProperties, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetPropertiesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetPropertiesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetPropertiesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetPropertiesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetPropertiesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) AppendPath(path BatchGetPropertiesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetPropertiesResponse_FieldPath))
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) GetPaths() []BatchGetPropertiesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetPropertiesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) Set(target, source *BatchGetPropertiesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetPropertiesResponse), source.(*BatchGetPropertiesResponse))
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) Project(source *BatchGetPropertiesResponse) *BatchGetPropertiesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetPropertiesResponse{}
	propertiesMask := &property.Property_FieldMask{}
	wholePropertiesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetPropertiesResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetPropertiesResponse_FieldPathSelectorProperties:
				result.Properties = source.Properties
				wholePropertiesAccepted = true
			case BatchGetPropertiesResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetPropertiesResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetPropertiesResponse_FieldPathSelectorProperties:
				propertiesMask.AppendPath(tp.subPath.(property.Property_FieldPath))
			}
		}
	}
	if wholePropertiesAccepted == false && len(propertiesMask.Paths) > 0 {
		for _, sourceItem := range source.GetProperties() {
			result.Properties = append(result.Properties, propertiesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetPropertiesResponse))
}

func (fieldMask *BatchGetPropertiesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListPropertiesRequest_FieldMask struct {
	Paths []ListPropertiesRequest_FieldPath
}

func FullListPropertiesRequest_FieldMask() *ListPropertiesRequest_FieldMask {
	res := &ListPropertiesRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListPropertiesRequest_FieldTerminalPath{selector: ListPropertiesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListPropertiesRequest_FieldTerminalPath{selector: ListPropertiesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListPropertiesRequest_FieldTerminalPath{selector: ListPropertiesRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListPropertiesRequest_FieldTerminalPath{selector: ListPropertiesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListPropertiesRequest_FieldTerminalPath{selector: ListPropertiesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListPropertiesRequest_FieldTerminalPath{selector: ListPropertiesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListPropertiesRequest_FieldTerminalPath{selector: ListPropertiesRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListPropertiesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListPropertiesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListPropertiesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListPropertiesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListPropertiesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListPropertiesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListPropertiesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListPropertiesRequest_FieldPath(raw)
	})
}

func (fieldMask *ListPropertiesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListPropertiesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListPropertiesRequest_FieldMask) Subtract(other *ListPropertiesRequest_FieldMask) *ListPropertiesRequest_FieldMask {
	result := &ListPropertiesRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListPropertiesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListPropertiesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListPropertiesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListPropertiesRequest_FieldMask) FilterInputFields() *ListPropertiesRequest_FieldMask {
	result := &ListPropertiesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListPropertiesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListPropertiesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListPropertiesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListPropertiesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListPropertiesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListPropertiesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListPropertiesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListPropertiesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListPropertiesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListPropertiesRequest_FieldMask) AppendPath(path ListPropertiesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListPropertiesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListPropertiesRequest_FieldPath))
}

func (fieldMask *ListPropertiesRequest_FieldMask) GetPaths() []ListPropertiesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListPropertiesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListPropertiesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListPropertiesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListPropertiesRequest_FieldMask) Set(target, source *ListPropertiesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListPropertiesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListPropertiesRequest), source.(*ListPropertiesRequest))
}

func (fieldMask *ListPropertiesRequest_FieldMask) Project(source *ListPropertiesRequest) *ListPropertiesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListPropertiesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListPropertiesRequest_FieldTerminalPath:
			switch tp.selector {
			case ListPropertiesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListPropertiesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListPropertiesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListPropertiesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListPropertiesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListPropertiesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListPropertiesRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListPropertiesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListPropertiesRequest))
}

func (fieldMask *ListPropertiesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListPropertiesResponse_FieldMask struct {
	Paths []ListPropertiesResponse_FieldPath
}

func FullListPropertiesResponse_FieldMask() *ListPropertiesResponse_FieldMask {
	res := &ListPropertiesResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListPropertiesResponse_FieldTerminalPath{selector: ListPropertiesResponse_FieldPathSelectorProperties})
	res.Paths = append(res.Paths, &ListPropertiesResponse_FieldTerminalPath{selector: ListPropertiesResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListPropertiesResponse_FieldTerminalPath{selector: ListPropertiesResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListPropertiesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListPropertiesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListPropertiesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListPropertiesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListPropertiesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListPropertiesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListPropertiesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListPropertiesResponse_FieldPath(raw)
	})
}

func (fieldMask *ListPropertiesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListPropertiesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListPropertiesResponse_FieldMask) Subtract(other *ListPropertiesResponse_FieldMask) *ListPropertiesResponse_FieldMask {
	result := &ListPropertiesResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListPropertiesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListPropertiesResponse_FieldPathSelectorProperties: &property.Property_FieldMask{},
	}
	mySubMasks := map[ListPropertiesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListPropertiesResponse_FieldPathSelectorProperties: &property.Property_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListPropertiesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListPropertiesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListPropertiesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListPropertiesResponse_FieldPathSelectorProperties:
						mySubMasks[ListPropertiesResponse_FieldPathSelectorProperties] = property.FullProperty_FieldMask()
					}
				} else if tp, ok := path.(*ListPropertiesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListPropertiesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListPropertiesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListPropertiesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListPropertiesResponse_FieldMask) FilterInputFields() *ListPropertiesResponse_FieldMask {
	result := &ListPropertiesResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListPropertiesResponse_FieldPathSelectorProperties:
			if _, ok := path.(*ListPropertiesResponse_FieldTerminalPath); ok {
				for _, subpath := range property.FullProperty_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListPropertiesResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListPropertiesResponse_FieldSubPath); ok {
				selectedMask := &property.Property_FieldMask{
					Paths: []property.Property_FieldPath{sub.subPath.(property.Property_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListPropertiesResponse_FieldSubPath{selector: ListPropertiesResponse_FieldPathSelectorProperties, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListPropertiesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListPropertiesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListPropertiesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListPropertiesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListPropertiesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListPropertiesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListPropertiesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListPropertiesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListPropertiesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListPropertiesResponse_FieldMask) AppendPath(path ListPropertiesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListPropertiesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListPropertiesResponse_FieldPath))
}

func (fieldMask *ListPropertiesResponse_FieldMask) GetPaths() []ListPropertiesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListPropertiesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListPropertiesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListPropertiesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListPropertiesResponse_FieldMask) Set(target, source *ListPropertiesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListPropertiesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListPropertiesResponse), source.(*ListPropertiesResponse))
}

func (fieldMask *ListPropertiesResponse_FieldMask) Project(source *ListPropertiesResponse) *ListPropertiesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListPropertiesResponse{}
	propertiesMask := &property.Property_FieldMask{}
	wholePropertiesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListPropertiesResponse_FieldTerminalPath:
			switch tp.selector {
			case ListPropertiesResponse_FieldPathSelectorProperties:
				result.Properties = source.Properties
				wholePropertiesAccepted = true
			case ListPropertiesResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListPropertiesResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListPropertiesResponse_FieldSubPath:
			switch tp.selector {
			case ListPropertiesResponse_FieldPathSelectorProperties:
				propertiesMask.AppendPath(tp.subPath.(property.Property_FieldPath))
			}
		}
	}
	if wholePropertiesAccepted == false && len(propertiesMask.Paths) > 0 {
		for _, sourceItem := range source.GetProperties() {
			result.Properties = append(result.Properties, propertiesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListPropertiesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListPropertiesResponse))
}

func (fieldMask *ListPropertiesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPropertyRequest_FieldMask struct {
	Paths []WatchPropertyRequest_FieldPath
}

func FullWatchPropertyRequest_FieldMask() *WatchPropertyRequest_FieldMask {
	res := &WatchPropertyRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchPropertyRequest_FieldTerminalPath{selector: WatchPropertyRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchPropertyRequest_FieldTerminalPath{selector: WatchPropertyRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchPropertyRequest_FieldTerminalPath{selector: WatchPropertyRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchPropertyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPropertyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPropertyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPropertyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPropertyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPropertyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPropertyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPropertyRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchPropertyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPropertyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPropertyRequest_FieldMask) Subtract(other *WatchPropertyRequest_FieldMask) *WatchPropertyRequest_FieldMask {
	result := &WatchPropertyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPropertyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPropertyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPropertyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPropertyRequest_FieldMask) FilterInputFields() *WatchPropertyRequest_FieldMask {
	result := &WatchPropertyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPropertyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPropertyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPropertyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPropertyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPropertyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPropertyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPropertyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPropertyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertyRequest_FieldMask) AppendPath(path WatchPropertyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPropertyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPropertyRequest_FieldPath))
}

func (fieldMask *WatchPropertyRequest_FieldMask) GetPaths() []WatchPropertyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPropertyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPropertyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPropertyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPropertyRequest_FieldMask) Set(target, source *WatchPropertyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPropertyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPropertyRequest), source.(*WatchPropertyRequest))
}

func (fieldMask *WatchPropertyRequest_FieldMask) Project(source *WatchPropertyRequest) *WatchPropertyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPropertyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPropertyRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchPropertyRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchPropertyRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchPropertyRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchPropertyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPropertyRequest))
}

func (fieldMask *WatchPropertyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPropertyResponse_FieldMask struct {
	Paths []WatchPropertyResponse_FieldPath
}

func FullWatchPropertyResponse_FieldMask() *WatchPropertyResponse_FieldMask {
	res := &WatchPropertyResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchPropertyResponse_FieldTerminalPath{selector: WatchPropertyResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchPropertyResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPropertyResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPropertyResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPropertyResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPropertyResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPropertyResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPropertyResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPropertyResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchPropertyResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPropertyResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPropertyResponse_FieldMask) Subtract(other *WatchPropertyResponse_FieldMask) *WatchPropertyResponse_FieldMask {
	result := &WatchPropertyResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPropertyResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPropertyResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPropertyResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPropertyResponse_FieldMask) FilterInputFields() *WatchPropertyResponse_FieldMask {
	result := &WatchPropertyResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPropertyResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPropertyResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPropertyResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPropertyResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPropertyResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPropertyResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertyResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPropertyResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPropertyResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertyResponse_FieldMask) AppendPath(path WatchPropertyResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPropertyResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPropertyResponse_FieldPath))
}

func (fieldMask *WatchPropertyResponse_FieldMask) GetPaths() []WatchPropertyResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPropertyResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPropertyResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPropertyResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPropertyResponse_FieldMask) Set(target, source *WatchPropertyResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPropertyResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPropertyResponse), source.(*WatchPropertyResponse))
}

func (fieldMask *WatchPropertyResponse_FieldMask) Project(source *WatchPropertyResponse) *WatchPropertyResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPropertyResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPropertyResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchPropertyResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchPropertyResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPropertyResponse))
}

func (fieldMask *WatchPropertyResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPropertiesRequest_FieldMask struct {
	Paths []WatchPropertiesRequest_FieldPath
}

func FullWatchPropertiesRequest_FieldMask() *WatchPropertiesRequest_FieldMask {
	res := &WatchPropertiesRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchPropertiesRequest_FieldTerminalPath{selector: WatchPropertiesRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchPropertiesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPropertiesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPropertiesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPropertiesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPropertiesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPropertiesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPropertiesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPropertiesRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchPropertiesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPropertiesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPropertiesRequest_FieldMask) Subtract(other *WatchPropertiesRequest_FieldMask) *WatchPropertiesRequest_FieldMask {
	result := &WatchPropertiesRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPropertiesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPropertiesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPropertiesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPropertiesRequest_FieldMask) FilterInputFields() *WatchPropertiesRequest_FieldMask {
	result := &WatchPropertiesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPropertiesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPropertiesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPropertiesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPropertiesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPropertiesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPropertiesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertiesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPropertiesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPropertiesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertiesRequest_FieldMask) AppendPath(path WatchPropertiesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPropertiesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPropertiesRequest_FieldPath))
}

func (fieldMask *WatchPropertiesRequest_FieldMask) GetPaths() []WatchPropertiesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPropertiesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPropertiesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPropertiesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPropertiesRequest_FieldMask) Set(target, source *WatchPropertiesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPropertiesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPropertiesRequest), source.(*WatchPropertiesRequest))
}

func (fieldMask *WatchPropertiesRequest_FieldMask) Project(source *WatchPropertiesRequest) *WatchPropertiesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPropertiesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPropertiesRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchPropertiesRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchPropertiesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchPropertiesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchPropertiesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchPropertiesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchPropertiesRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchPropertiesRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchPropertiesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchPropertiesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchPropertiesRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchPropertiesRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchPropertiesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPropertiesRequest))
}

func (fieldMask *WatchPropertiesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPropertiesResponse_FieldMask struct {
	Paths []WatchPropertiesResponse_FieldPath
}

func FullWatchPropertiesResponse_FieldMask() *WatchPropertiesResponse_FieldMask {
	res := &WatchPropertiesResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchPropertiesResponse_FieldTerminalPath{selector: WatchPropertiesResponse_FieldPathSelectorPropertyChanges})
	res.Paths = append(res.Paths, &WatchPropertiesResponse_FieldTerminalPath{selector: WatchPropertiesResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchPropertiesResponse_FieldTerminalPath{selector: WatchPropertiesResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchPropertiesResponse_FieldTerminalPath{selector: WatchPropertiesResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchPropertiesResponse_FieldTerminalPath{selector: WatchPropertiesResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchPropertiesResponse_FieldTerminalPath{selector: WatchPropertiesResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchPropertiesResponse_FieldTerminalPath{selector: WatchPropertiesResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchPropertiesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPropertiesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPropertiesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPropertiesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPropertiesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPropertiesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPropertiesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPropertiesResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchPropertiesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPropertiesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPropertiesResponse_FieldMask) Subtract(other *WatchPropertiesResponse_FieldMask) *WatchPropertiesResponse_FieldMask {
	result := &WatchPropertiesResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchPropertiesResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchPropertiesResponse_FieldPathSelectorPageTokenChange: &WatchPropertiesResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchPropertiesResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchPropertiesResponse_FieldPathSelectorPageTokenChange: &WatchPropertiesResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPropertiesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchPropertiesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchPropertiesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchPropertiesResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchPropertiesResponse_FieldPathSelectorPageTokenChange] = FullWatchPropertiesResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchPropertiesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchPropertiesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPropertiesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPropertiesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPropertiesResponse_FieldMask) FilterInputFields() *WatchPropertiesResponse_FieldMask {
	result := &WatchPropertiesResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPropertiesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPropertiesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPropertiesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPropertiesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPropertiesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPropertiesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertiesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPropertiesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPropertiesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertiesResponse_FieldMask) AppendPath(path WatchPropertiesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPropertiesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPropertiesResponse_FieldPath))
}

func (fieldMask *WatchPropertiesResponse_FieldMask) GetPaths() []WatchPropertiesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPropertiesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPropertiesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPropertiesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPropertiesResponse_FieldMask) Set(target, source *WatchPropertiesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPropertiesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPropertiesResponse), source.(*WatchPropertiesResponse))
}

func (fieldMask *WatchPropertiesResponse_FieldMask) Project(source *WatchPropertiesResponse) *WatchPropertiesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPropertiesResponse{}
	pageTokenChangeMask := &WatchPropertiesResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPropertiesResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchPropertiesResponse_FieldPathSelectorPropertyChanges:
				result.PropertyChanges = source.PropertyChanges
			case WatchPropertiesResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchPropertiesResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchPropertiesResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchPropertiesResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchPropertiesResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchPropertiesResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchPropertiesResponse_FieldSubPath:
			switch tp.selector {
			case WatchPropertiesResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchPropertiesResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchPropertiesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPropertiesResponse))
}

func (fieldMask *WatchPropertiesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPropertiesResponse_PageTokenChange_FieldMask struct {
	Paths []WatchPropertiesResponsePageTokenChange_FieldPath
}

func FullWatchPropertiesResponse_PageTokenChange_FieldMask() *WatchPropertiesResponse_PageTokenChange_FieldMask {
	res := &WatchPropertiesResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchPropertiesResponsePageTokenChange_FieldTerminalPath{selector: WatchPropertiesResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchPropertiesResponsePageTokenChange_FieldTerminalPath{selector: WatchPropertiesResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPropertiesResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPropertiesResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPropertiesResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) Subtract(other *WatchPropertiesResponse_PageTokenChange_FieldMask) *WatchPropertiesResponse_PageTokenChange_FieldMask {
	result := &WatchPropertiesResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPropertiesResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPropertiesResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchPropertiesResponse_PageTokenChange_FieldMask {
	result := &WatchPropertiesResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPropertiesResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPropertiesResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPropertiesResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPropertiesResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) AppendPath(path WatchPropertiesResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPropertiesResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) GetPaths() []WatchPropertiesResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPropertiesResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) Set(target, source *WatchPropertiesResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPropertiesResponse_PageTokenChange), source.(*WatchPropertiesResponse_PageTokenChange))
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) Project(source *WatchPropertiesResponse_PageTokenChange) *WatchPropertiesResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPropertiesResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPropertiesResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchPropertiesResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchPropertiesResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPropertiesResponse_PageTokenChange))
}

func (fieldMask *WatchPropertiesResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreatePropertyRequest_FieldMask struct {
	Paths []CreatePropertyRequest_FieldPath
}

func FullCreatePropertyRequest_FieldMask() *CreatePropertyRequest_FieldMask {
	res := &CreatePropertyRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreatePropertyRequest_FieldTerminalPath{selector: CreatePropertyRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreatePropertyRequest_FieldTerminalPath{selector: CreatePropertyRequest_FieldPathSelectorProperty})
	return res
}

func (fieldMask *CreatePropertyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreatePropertyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreatePropertyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreatePropertyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreatePropertyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreatePropertyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreatePropertyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreatePropertyRequest_FieldPath(raw)
	})
}

func (fieldMask *CreatePropertyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreatePropertyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreatePropertyRequest_FieldMask) Subtract(other *CreatePropertyRequest_FieldMask) *CreatePropertyRequest_FieldMask {
	result := &CreatePropertyRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreatePropertyRequest_FieldPathSelector]gotenobject.FieldMask{
		CreatePropertyRequest_FieldPathSelectorProperty: &property.Property_FieldMask{},
	}
	mySubMasks := map[CreatePropertyRequest_FieldPathSelector]gotenobject.FieldMask{
		CreatePropertyRequest_FieldPathSelectorProperty: &property.Property_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreatePropertyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreatePropertyRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreatePropertyRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreatePropertyRequest_FieldPathSelectorProperty:
						mySubMasks[CreatePropertyRequest_FieldPathSelectorProperty] = property.FullProperty_FieldMask()
					}
				} else if tp, ok := path.(*CreatePropertyRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreatePropertyRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreatePropertyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreatePropertyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreatePropertyRequest_FieldMask) FilterInputFields() *CreatePropertyRequest_FieldMask {
	result := &CreatePropertyRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreatePropertyRequest_FieldPathSelectorProperty:
			if _, ok := path.(*CreatePropertyRequest_FieldTerminalPath); ok {
				for _, subpath := range property.FullProperty_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreatePropertyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreatePropertyRequest_FieldSubPath); ok {
				selectedMask := &property.Property_FieldMask{
					Paths: []property.Property_FieldPath{sub.subPath.(property.Property_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreatePropertyRequest_FieldSubPath{selector: CreatePropertyRequest_FieldPathSelectorProperty, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreatePropertyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreatePropertyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreatePropertyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreatePropertyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreatePropertyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreatePropertyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreatePropertyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreatePropertyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreatePropertyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreatePropertyRequest_FieldMask) AppendPath(path CreatePropertyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreatePropertyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreatePropertyRequest_FieldPath))
}

func (fieldMask *CreatePropertyRequest_FieldMask) GetPaths() []CreatePropertyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreatePropertyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreatePropertyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreatePropertyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreatePropertyRequest_FieldMask) Set(target, source *CreatePropertyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreatePropertyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreatePropertyRequest), source.(*CreatePropertyRequest))
}

func (fieldMask *CreatePropertyRequest_FieldMask) Project(source *CreatePropertyRequest) *CreatePropertyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreatePropertyRequest{}
	propertyMask := &property.Property_FieldMask{}
	wholePropertyAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreatePropertyRequest_FieldTerminalPath:
			switch tp.selector {
			case CreatePropertyRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreatePropertyRequest_FieldPathSelectorProperty:
				result.Property = source.Property
				wholePropertyAccepted = true
			}
		case *CreatePropertyRequest_FieldSubPath:
			switch tp.selector {
			case CreatePropertyRequest_FieldPathSelectorProperty:
				propertyMask.AppendPath(tp.subPath.(property.Property_FieldPath))
			}
		}
	}
	if wholePropertyAccepted == false && len(propertyMask.Paths) > 0 {
		result.Property = propertyMask.Project(source.GetProperty())
	}
	return result
}

func (fieldMask *CreatePropertyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreatePropertyRequest))
}

func (fieldMask *CreatePropertyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdatePropertyRequest_FieldMask struct {
	Paths []UpdatePropertyRequest_FieldPath
}

func FullUpdatePropertyRequest_FieldMask() *UpdatePropertyRequest_FieldMask {
	res := &UpdatePropertyRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdatePropertyRequest_FieldTerminalPath{selector: UpdatePropertyRequest_FieldPathSelectorProperty})
	res.Paths = append(res.Paths, &UpdatePropertyRequest_FieldTerminalPath{selector: UpdatePropertyRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdatePropertyRequest_FieldTerminalPath{selector: UpdatePropertyRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdatePropertyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdatePropertyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdatePropertyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdatePropertyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdatePropertyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdatePropertyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdatePropertyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdatePropertyRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdatePropertyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdatePropertyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdatePropertyRequest_FieldMask) Subtract(other *UpdatePropertyRequest_FieldMask) *UpdatePropertyRequest_FieldMask {
	result := &UpdatePropertyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdatePropertyRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdatePropertyRequest_FieldPathSelectorProperty: &property.Property_FieldMask{},
		UpdatePropertyRequest_FieldPathSelectorCas:      &UpdatePropertyRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdatePropertyRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdatePropertyRequest_FieldPathSelectorProperty: &property.Property_FieldMask{},
		UpdatePropertyRequest_FieldPathSelectorCas:      &UpdatePropertyRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdatePropertyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdatePropertyRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdatePropertyRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdatePropertyRequest_FieldPathSelectorProperty:
						mySubMasks[UpdatePropertyRequest_FieldPathSelectorProperty] = property.FullProperty_FieldMask()
					case UpdatePropertyRequest_FieldPathSelectorCas:
						mySubMasks[UpdatePropertyRequest_FieldPathSelectorCas] = FullUpdatePropertyRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdatePropertyRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdatePropertyRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdatePropertyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdatePropertyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdatePropertyRequest_FieldMask) FilterInputFields() *UpdatePropertyRequest_FieldMask {
	result := &UpdatePropertyRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdatePropertyRequest_FieldPathSelectorProperty:
			if _, ok := path.(*UpdatePropertyRequest_FieldTerminalPath); ok {
				for _, subpath := range property.FullProperty_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePropertyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdatePropertyRequest_FieldSubPath); ok {
				selectedMask := &property.Property_FieldMask{
					Paths: []property.Property_FieldPath{sub.subPath.(property.Property_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePropertyRequest_FieldSubPath{selector: UpdatePropertyRequest_FieldPathSelectorProperty, subPath: allowedPath})
				}
			}
		case UpdatePropertyRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdatePropertyRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdatePropertyRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePropertyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdatePropertyRequest_FieldSubPath); ok {
				selectedMask := &UpdatePropertyRequest_CAS_FieldMask{
					Paths: []UpdatePropertyRequestCAS_FieldPath{sub.subPath.(UpdatePropertyRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePropertyRequest_FieldSubPath{selector: UpdatePropertyRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdatePropertyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdatePropertyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdatePropertyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdatePropertyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdatePropertyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdatePropertyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdatePropertyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdatePropertyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdatePropertyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdatePropertyRequest_FieldMask) AppendPath(path UpdatePropertyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdatePropertyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdatePropertyRequest_FieldPath))
}

func (fieldMask *UpdatePropertyRequest_FieldMask) GetPaths() []UpdatePropertyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdatePropertyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdatePropertyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdatePropertyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdatePropertyRequest_FieldMask) Set(target, source *UpdatePropertyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdatePropertyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdatePropertyRequest), source.(*UpdatePropertyRequest))
}

func (fieldMask *UpdatePropertyRequest_FieldMask) Project(source *UpdatePropertyRequest) *UpdatePropertyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdatePropertyRequest{}
	propertyMask := &property.Property_FieldMask{}
	wholePropertyAccepted := false
	casMask := &UpdatePropertyRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdatePropertyRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdatePropertyRequest_FieldPathSelectorProperty:
				result.Property = source.Property
				wholePropertyAccepted = true
			case UpdatePropertyRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdatePropertyRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdatePropertyRequest_FieldSubPath:
			switch tp.selector {
			case UpdatePropertyRequest_FieldPathSelectorProperty:
				propertyMask.AppendPath(tp.subPath.(property.Property_FieldPath))
			case UpdatePropertyRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdatePropertyRequestCAS_FieldPath))
			}
		}
	}
	if wholePropertyAccepted == false && len(propertyMask.Paths) > 0 {
		result.Property = propertyMask.Project(source.GetProperty())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdatePropertyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdatePropertyRequest))
}

func (fieldMask *UpdatePropertyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdatePropertyRequest_CAS_FieldMask struct {
	Paths []UpdatePropertyRequestCAS_FieldPath
}

func FullUpdatePropertyRequest_CAS_FieldMask() *UpdatePropertyRequest_CAS_FieldMask {
	res := &UpdatePropertyRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdatePropertyRequestCAS_FieldTerminalPath{selector: UpdatePropertyRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdatePropertyRequestCAS_FieldTerminalPath{selector: UpdatePropertyRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdatePropertyRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdatePropertyRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdatePropertyRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) Subtract(other *UpdatePropertyRequest_CAS_FieldMask) *UpdatePropertyRequest_CAS_FieldMask {
	result := &UpdatePropertyRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdatePropertyRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdatePropertyRequestCAS_FieldPathSelectorConditionalState: &property.Property_FieldMask{},
	}
	mySubMasks := map[UpdatePropertyRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdatePropertyRequestCAS_FieldPathSelectorConditionalState: &property.Property_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdatePropertyRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdatePropertyRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdatePropertyRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdatePropertyRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdatePropertyRequestCAS_FieldPathSelectorConditionalState] = property.FullProperty_FieldMask()
					}
				} else if tp, ok := path.(*UpdatePropertyRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdatePropertyRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdatePropertyRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) FilterInputFields() *UpdatePropertyRequest_CAS_FieldMask {
	result := &UpdatePropertyRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdatePropertyRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdatePropertyRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range property.FullProperty_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePropertyRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdatePropertyRequestCAS_FieldSubPath); ok {
				selectedMask := &property.Property_FieldMask{
					Paths: []property.Property_FieldPath{sub.subPath.(property.Property_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePropertyRequestCAS_FieldSubPath{selector: UpdatePropertyRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdatePropertyRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdatePropertyRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdatePropertyRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdatePropertyRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) AppendPath(path UpdatePropertyRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdatePropertyRequestCAS_FieldPath))
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) GetPaths() []UpdatePropertyRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdatePropertyRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) Set(target, source *UpdatePropertyRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdatePropertyRequest_CAS), source.(*UpdatePropertyRequest_CAS))
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) Project(source *UpdatePropertyRequest_CAS) *UpdatePropertyRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdatePropertyRequest_CAS{}
	conditionalStateMask := &property.Property_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdatePropertyRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdatePropertyRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdatePropertyRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdatePropertyRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdatePropertyRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(property.Property_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdatePropertyRequest_CAS))
}

func (fieldMask *UpdatePropertyRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeletePropertyRequest_FieldMask struct {
	Paths []DeletePropertyRequest_FieldPath
}

func FullDeletePropertyRequest_FieldMask() *DeletePropertyRequest_FieldMask {
	res := &DeletePropertyRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeletePropertyRequest_FieldTerminalPath{selector: DeletePropertyRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeletePropertyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeletePropertyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeletePropertyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeletePropertyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeletePropertyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeletePropertyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeletePropertyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeletePropertyRequest_FieldPath(raw)
	})
}

func (fieldMask *DeletePropertyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeletePropertyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeletePropertyRequest_FieldMask) Subtract(other *DeletePropertyRequest_FieldMask) *DeletePropertyRequest_FieldMask {
	result := &DeletePropertyRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeletePropertyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeletePropertyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeletePropertyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeletePropertyRequest_FieldMask) FilterInputFields() *DeletePropertyRequest_FieldMask {
	result := &DeletePropertyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeletePropertyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeletePropertyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeletePropertyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeletePropertyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeletePropertyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeletePropertyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeletePropertyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeletePropertyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeletePropertyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeletePropertyRequest_FieldMask) AppendPath(path DeletePropertyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeletePropertyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeletePropertyRequest_FieldPath))
}

func (fieldMask *DeletePropertyRequest_FieldMask) GetPaths() []DeletePropertyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeletePropertyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeletePropertyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeletePropertyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeletePropertyRequest_FieldMask) Set(target, source *DeletePropertyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeletePropertyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeletePropertyRequest), source.(*DeletePropertyRequest))
}

func (fieldMask *DeletePropertyRequest_FieldMask) Project(source *DeletePropertyRequest) *DeletePropertyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeletePropertyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeletePropertyRequest_FieldTerminalPath:
			switch tp.selector {
			case DeletePropertyRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeletePropertyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeletePropertyRequest))
}

func (fieldMask *DeletePropertyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
