// Code generated by protoc-gen-goten-object
// File: workplace/proto/v1alpha/device_group_service.proto
// DO NOT EDIT!!!

package device_group_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha/project"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	device_group "github.com/cloudwan/workplace-sdk/resources/v1alpha/device_group"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &iam_project.Project{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
	_ = &device_group.DeviceGroup{}
)

type GetDeviceGroupRequest_FieldMask struct {
	Paths []GetDeviceGroupRequest_FieldPath
}

func FullGetDeviceGroupRequest_FieldMask() *GetDeviceGroupRequest_FieldMask {
	res := &GetDeviceGroupRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetDeviceGroupRequest_FieldTerminalPath{selector: GetDeviceGroupRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetDeviceGroupRequest_FieldTerminalPath{selector: GetDeviceGroupRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetDeviceGroupRequest_FieldTerminalPath{selector: GetDeviceGroupRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetDeviceGroupRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetDeviceGroupRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetDeviceGroupRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetDeviceGroupRequest_FieldPath(raw)
	})
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetDeviceGroupRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) Subtract(other *GetDeviceGroupRequest_FieldMask) *GetDeviceGroupRequest_FieldMask {
	result := &GetDeviceGroupRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetDeviceGroupRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetDeviceGroupRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetDeviceGroupRequest_FieldMask) FilterInputFields() *GetDeviceGroupRequest_FieldMask {
	result := &GetDeviceGroupRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetDeviceGroupRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetDeviceGroupRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetDeviceGroupRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetDeviceGroupRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetDeviceGroupRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) AppendPath(path GetDeviceGroupRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetDeviceGroupRequest_FieldPath))
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) GetPaths() []GetDeviceGroupRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetDeviceGroupRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) Set(target, source *GetDeviceGroupRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetDeviceGroupRequest), source.(*GetDeviceGroupRequest))
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) Project(source *GetDeviceGroupRequest) *GetDeviceGroupRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetDeviceGroupRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetDeviceGroupRequest_FieldTerminalPath:
			switch tp.selector {
			case GetDeviceGroupRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetDeviceGroupRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetDeviceGroupRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetDeviceGroupRequest))
}

func (fieldMask *GetDeviceGroupRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetDeviceGroupsRequest_FieldMask struct {
	Paths []BatchGetDeviceGroupsRequest_FieldPath
}

func FullBatchGetDeviceGroupsRequest_FieldMask() *BatchGetDeviceGroupsRequest_FieldMask {
	res := &BatchGetDeviceGroupsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetDeviceGroupsRequest_FieldTerminalPath{selector: BatchGetDeviceGroupsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &BatchGetDeviceGroupsRequest_FieldTerminalPath{selector: BatchGetDeviceGroupsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetDeviceGroupsRequest_FieldTerminalPath{selector: BatchGetDeviceGroupsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetDeviceGroupsRequest_FieldTerminalPath{selector: BatchGetDeviceGroupsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetDeviceGroupsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetDeviceGroupsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetDeviceGroupsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) Subtract(other *BatchGetDeviceGroupsRequest_FieldMask) *BatchGetDeviceGroupsRequest_FieldMask {
	result := &BatchGetDeviceGroupsRequest_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetDeviceGroupsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetDeviceGroupsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) FilterInputFields() *BatchGetDeviceGroupsRequest_FieldMask {
	result := &BatchGetDeviceGroupsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetDeviceGroupsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetDeviceGroupsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetDeviceGroupsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetDeviceGroupsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) AppendPath(path BatchGetDeviceGroupsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetDeviceGroupsRequest_FieldPath))
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) GetPaths() []BatchGetDeviceGroupsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetDeviceGroupsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) Set(target, source *BatchGetDeviceGroupsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetDeviceGroupsRequest), source.(*BatchGetDeviceGroupsRequest))
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) Project(source *BatchGetDeviceGroupsRequest) *BatchGetDeviceGroupsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetDeviceGroupsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetDeviceGroupsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetDeviceGroupsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case BatchGetDeviceGroupsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetDeviceGroupsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetDeviceGroupsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetDeviceGroupsRequest))
}

func (fieldMask *BatchGetDeviceGroupsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetDeviceGroupsResponse_FieldMask struct {
	Paths []BatchGetDeviceGroupsResponse_FieldPath
}

func FullBatchGetDeviceGroupsResponse_FieldMask() *BatchGetDeviceGroupsResponse_FieldMask {
	res := &BatchGetDeviceGroupsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetDeviceGroupsResponse_FieldTerminalPath{selector: BatchGetDeviceGroupsResponse_FieldPathSelectorDeviceGroups})
	res.Paths = append(res.Paths, &BatchGetDeviceGroupsResponse_FieldTerminalPath{selector: BatchGetDeviceGroupsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetDeviceGroupsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetDeviceGroupsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetDeviceGroupsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) Subtract(other *BatchGetDeviceGroupsResponse_FieldMask) *BatchGetDeviceGroupsResponse_FieldMask {
	result := &BatchGetDeviceGroupsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetDeviceGroupsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetDeviceGroupsResponse_FieldPathSelectorDeviceGroups: &device_group.DeviceGroup_FieldMask{},
	}
	mySubMasks := map[BatchGetDeviceGroupsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetDeviceGroupsResponse_FieldPathSelectorDeviceGroups: &device_group.DeviceGroup_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetDeviceGroupsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetDeviceGroupsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetDeviceGroupsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetDeviceGroupsResponse_FieldPathSelectorDeviceGroups:
						mySubMasks[BatchGetDeviceGroupsResponse_FieldPathSelectorDeviceGroups] = device_group.FullDeviceGroup_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetDeviceGroupsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetDeviceGroupsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetDeviceGroupsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) FilterInputFields() *BatchGetDeviceGroupsResponse_FieldMask {
	result := &BatchGetDeviceGroupsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetDeviceGroupsResponse_FieldPathSelectorDeviceGroups:
			if _, ok := path.(*BatchGetDeviceGroupsResponse_FieldTerminalPath); ok {
				for _, subpath := range device_group.FullDeviceGroup_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetDeviceGroupsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetDeviceGroupsResponse_FieldSubPath); ok {
				selectedMask := &device_group.DeviceGroup_FieldMask{
					Paths: []device_group.DeviceGroup_FieldPath{sub.subPath.(device_group.DeviceGroup_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetDeviceGroupsResponse_FieldSubPath{selector: BatchGetDeviceGroupsResponse_FieldPathSelectorDeviceGroups, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetDeviceGroupsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetDeviceGroupsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetDeviceGroupsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetDeviceGroupsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) AppendPath(path BatchGetDeviceGroupsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetDeviceGroupsResponse_FieldPath))
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) GetPaths() []BatchGetDeviceGroupsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetDeviceGroupsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) Set(target, source *BatchGetDeviceGroupsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetDeviceGroupsResponse), source.(*BatchGetDeviceGroupsResponse))
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) Project(source *BatchGetDeviceGroupsResponse) *BatchGetDeviceGroupsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetDeviceGroupsResponse{}
	deviceGroupsMask := &device_group.DeviceGroup_FieldMask{}
	wholeDeviceGroupsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetDeviceGroupsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetDeviceGroupsResponse_FieldPathSelectorDeviceGroups:
				result.DeviceGroups = source.DeviceGroups
				wholeDeviceGroupsAccepted = true
			case BatchGetDeviceGroupsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetDeviceGroupsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetDeviceGroupsResponse_FieldPathSelectorDeviceGroups:
				deviceGroupsMask.AppendPath(tp.subPath.(device_group.DeviceGroup_FieldPath))
			}
		}
	}
	if wholeDeviceGroupsAccepted == false && len(deviceGroupsMask.Paths) > 0 {
		for _, sourceItem := range source.GetDeviceGroups() {
			result.DeviceGroups = append(result.DeviceGroups, deviceGroupsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetDeviceGroupsResponse))
}

func (fieldMask *BatchGetDeviceGroupsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListDeviceGroupsRequest_FieldMask struct {
	Paths []ListDeviceGroupsRequest_FieldPath
}

func FullListDeviceGroupsRequest_FieldMask() *ListDeviceGroupsRequest_FieldMask {
	res := &ListDeviceGroupsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListDeviceGroupsRequest_FieldTerminalPath{selector: ListDeviceGroupsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListDeviceGroupsRequest_FieldTerminalPath{selector: ListDeviceGroupsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListDeviceGroupsRequest_FieldTerminalPath{selector: ListDeviceGroupsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListDeviceGroupsRequest_FieldTerminalPath{selector: ListDeviceGroupsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListDeviceGroupsRequest_FieldTerminalPath{selector: ListDeviceGroupsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListDeviceGroupsRequest_FieldTerminalPath{selector: ListDeviceGroupsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListDeviceGroupsRequest_FieldTerminalPath{selector: ListDeviceGroupsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListDeviceGroupsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListDeviceGroupsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListDeviceGroupsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListDeviceGroupsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) Subtract(other *ListDeviceGroupsRequest_FieldMask) *ListDeviceGroupsRequest_FieldMask {
	result := &ListDeviceGroupsRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListDeviceGroupsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListDeviceGroupsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListDeviceGroupsRequest_FieldMask) FilterInputFields() *ListDeviceGroupsRequest_FieldMask {
	result := &ListDeviceGroupsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListDeviceGroupsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListDeviceGroupsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListDeviceGroupsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListDeviceGroupsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListDeviceGroupsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) AppendPath(path ListDeviceGroupsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListDeviceGroupsRequest_FieldPath))
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) GetPaths() []ListDeviceGroupsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListDeviceGroupsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) Set(target, source *ListDeviceGroupsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListDeviceGroupsRequest), source.(*ListDeviceGroupsRequest))
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) Project(source *ListDeviceGroupsRequest) *ListDeviceGroupsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListDeviceGroupsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListDeviceGroupsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListDeviceGroupsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListDeviceGroupsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListDeviceGroupsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListDeviceGroupsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListDeviceGroupsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListDeviceGroupsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListDeviceGroupsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListDeviceGroupsRequest))
}

func (fieldMask *ListDeviceGroupsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListDeviceGroupsResponse_FieldMask struct {
	Paths []ListDeviceGroupsResponse_FieldPath
}

func FullListDeviceGroupsResponse_FieldMask() *ListDeviceGroupsResponse_FieldMask {
	res := &ListDeviceGroupsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListDeviceGroupsResponse_FieldTerminalPath{selector: ListDeviceGroupsResponse_FieldPathSelectorDeviceGroups})
	res.Paths = append(res.Paths, &ListDeviceGroupsResponse_FieldTerminalPath{selector: ListDeviceGroupsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListDeviceGroupsResponse_FieldTerminalPath{selector: ListDeviceGroupsResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListDeviceGroupsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListDeviceGroupsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListDeviceGroupsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListDeviceGroupsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) Subtract(other *ListDeviceGroupsResponse_FieldMask) *ListDeviceGroupsResponse_FieldMask {
	result := &ListDeviceGroupsResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListDeviceGroupsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListDeviceGroupsResponse_FieldPathSelectorDeviceGroups: &device_group.DeviceGroup_FieldMask{},
	}
	mySubMasks := map[ListDeviceGroupsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListDeviceGroupsResponse_FieldPathSelectorDeviceGroups: &device_group.DeviceGroup_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListDeviceGroupsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListDeviceGroupsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListDeviceGroupsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListDeviceGroupsResponse_FieldPathSelectorDeviceGroups:
						mySubMasks[ListDeviceGroupsResponse_FieldPathSelectorDeviceGroups] = device_group.FullDeviceGroup_FieldMask()
					}
				} else if tp, ok := path.(*ListDeviceGroupsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListDeviceGroupsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListDeviceGroupsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListDeviceGroupsResponse_FieldMask) FilterInputFields() *ListDeviceGroupsResponse_FieldMask {
	result := &ListDeviceGroupsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListDeviceGroupsResponse_FieldPathSelectorDeviceGroups:
			if _, ok := path.(*ListDeviceGroupsResponse_FieldTerminalPath); ok {
				for _, subpath := range device_group.FullDeviceGroup_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListDeviceGroupsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListDeviceGroupsResponse_FieldSubPath); ok {
				selectedMask := &device_group.DeviceGroup_FieldMask{
					Paths: []device_group.DeviceGroup_FieldPath{sub.subPath.(device_group.DeviceGroup_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListDeviceGroupsResponse_FieldSubPath{selector: ListDeviceGroupsResponse_FieldPathSelectorDeviceGroups, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListDeviceGroupsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListDeviceGroupsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListDeviceGroupsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListDeviceGroupsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListDeviceGroupsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) AppendPath(path ListDeviceGroupsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListDeviceGroupsResponse_FieldPath))
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) GetPaths() []ListDeviceGroupsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListDeviceGroupsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) Set(target, source *ListDeviceGroupsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListDeviceGroupsResponse), source.(*ListDeviceGroupsResponse))
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) Project(source *ListDeviceGroupsResponse) *ListDeviceGroupsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListDeviceGroupsResponse{}
	deviceGroupsMask := &device_group.DeviceGroup_FieldMask{}
	wholeDeviceGroupsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListDeviceGroupsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListDeviceGroupsResponse_FieldPathSelectorDeviceGroups:
				result.DeviceGroups = source.DeviceGroups
				wholeDeviceGroupsAccepted = true
			case ListDeviceGroupsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListDeviceGroupsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListDeviceGroupsResponse_FieldSubPath:
			switch tp.selector {
			case ListDeviceGroupsResponse_FieldPathSelectorDeviceGroups:
				deviceGroupsMask.AppendPath(tp.subPath.(device_group.DeviceGroup_FieldPath))
			}
		}
	}
	if wholeDeviceGroupsAccepted == false && len(deviceGroupsMask.Paths) > 0 {
		for _, sourceItem := range source.GetDeviceGroups() {
			result.DeviceGroups = append(result.DeviceGroups, deviceGroupsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListDeviceGroupsResponse))
}

func (fieldMask *ListDeviceGroupsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeviceGroupRequest_FieldMask struct {
	Paths []WatchDeviceGroupRequest_FieldPath
}

func FullWatchDeviceGroupRequest_FieldMask() *WatchDeviceGroupRequest_FieldMask {
	res := &WatchDeviceGroupRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeviceGroupRequest_FieldTerminalPath{selector: WatchDeviceGroupRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchDeviceGroupRequest_FieldTerminalPath{selector: WatchDeviceGroupRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchDeviceGroupRequest_FieldTerminalPath{selector: WatchDeviceGroupRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeviceGroupRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeviceGroupRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeviceGroupRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeviceGroupRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) Subtract(other *WatchDeviceGroupRequest_FieldMask) *WatchDeviceGroupRequest_FieldMask {
	result := &WatchDeviceGroupRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeviceGroupRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeviceGroupRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeviceGroupRequest_FieldMask) FilterInputFields() *WatchDeviceGroupRequest_FieldMask {
	result := &WatchDeviceGroupRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeviceGroupRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeviceGroupRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeviceGroupRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeviceGroupRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeviceGroupRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) AppendPath(path WatchDeviceGroupRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeviceGroupRequest_FieldPath))
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) GetPaths() []WatchDeviceGroupRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeviceGroupRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) Set(target, source *WatchDeviceGroupRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeviceGroupRequest), source.(*WatchDeviceGroupRequest))
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) Project(source *WatchDeviceGroupRequest) *WatchDeviceGroupRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeviceGroupRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeviceGroupRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchDeviceGroupRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchDeviceGroupRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchDeviceGroupRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeviceGroupRequest))
}

func (fieldMask *WatchDeviceGroupRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeviceGroupResponse_FieldMask struct {
	Paths []WatchDeviceGroupResponse_FieldPath
}

func FullWatchDeviceGroupResponse_FieldMask() *WatchDeviceGroupResponse_FieldMask {
	res := &WatchDeviceGroupResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeviceGroupResponse_FieldTerminalPath{selector: WatchDeviceGroupResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeviceGroupResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeviceGroupResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeviceGroupResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeviceGroupResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) Subtract(other *WatchDeviceGroupResponse_FieldMask) *WatchDeviceGroupResponse_FieldMask {
	result := &WatchDeviceGroupResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeviceGroupResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeviceGroupResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeviceGroupResponse_FieldMask) FilterInputFields() *WatchDeviceGroupResponse_FieldMask {
	result := &WatchDeviceGroupResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeviceGroupResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeviceGroupResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeviceGroupResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeviceGroupResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeviceGroupResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) AppendPath(path WatchDeviceGroupResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeviceGroupResponse_FieldPath))
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) GetPaths() []WatchDeviceGroupResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeviceGroupResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) Set(target, source *WatchDeviceGroupResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeviceGroupResponse), source.(*WatchDeviceGroupResponse))
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) Project(source *WatchDeviceGroupResponse) *WatchDeviceGroupResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeviceGroupResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeviceGroupResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchDeviceGroupResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeviceGroupResponse))
}

func (fieldMask *WatchDeviceGroupResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeviceGroupsRequest_FieldMask struct {
	Paths []WatchDeviceGroupsRequest_FieldPath
}

func FullWatchDeviceGroupsRequest_FieldMask() *WatchDeviceGroupsRequest_FieldMask {
	res := &WatchDeviceGroupsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchDeviceGroupsRequest_FieldTerminalPath{selector: WatchDeviceGroupsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeviceGroupsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeviceGroupsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeviceGroupsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeviceGroupsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) Subtract(other *WatchDeviceGroupsRequest_FieldMask) *WatchDeviceGroupsRequest_FieldMask {
	result := &WatchDeviceGroupsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeviceGroupsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeviceGroupsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeviceGroupsRequest_FieldMask) FilterInputFields() *WatchDeviceGroupsRequest_FieldMask {
	result := &WatchDeviceGroupsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeviceGroupsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeviceGroupsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeviceGroupsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeviceGroupsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeviceGroupsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) AppendPath(path WatchDeviceGroupsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeviceGroupsRequest_FieldPath))
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) GetPaths() []WatchDeviceGroupsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeviceGroupsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) Set(target, source *WatchDeviceGroupsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeviceGroupsRequest), source.(*WatchDeviceGroupsRequest))
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) Project(source *WatchDeviceGroupsRequest) *WatchDeviceGroupsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeviceGroupsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeviceGroupsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchDeviceGroupsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchDeviceGroupsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchDeviceGroupsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchDeviceGroupsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchDeviceGroupsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchDeviceGroupsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchDeviceGroupsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchDeviceGroupsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchDeviceGroupsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchDeviceGroupsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeviceGroupsRequest))
}

func (fieldMask *WatchDeviceGroupsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeviceGroupsResponse_FieldMask struct {
	Paths []WatchDeviceGroupsResponse_FieldPath
}

func FullWatchDeviceGroupsResponse_FieldMask() *WatchDeviceGroupsResponse_FieldMask {
	res := &WatchDeviceGroupsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeviceGroupsResponse_FieldTerminalPath{selector: WatchDeviceGroupsResponse_FieldPathSelectorDeviceGroupChanges})
	res.Paths = append(res.Paths, &WatchDeviceGroupsResponse_FieldTerminalPath{selector: WatchDeviceGroupsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchDeviceGroupsResponse_FieldTerminalPath{selector: WatchDeviceGroupsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchDeviceGroupsResponse_FieldTerminalPath{selector: WatchDeviceGroupsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchDeviceGroupsResponse_FieldTerminalPath{selector: WatchDeviceGroupsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchDeviceGroupsResponse_FieldTerminalPath{selector: WatchDeviceGroupsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchDeviceGroupsResponse_FieldTerminalPath{selector: WatchDeviceGroupsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeviceGroupsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeviceGroupsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeviceGroupsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeviceGroupsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) Subtract(other *WatchDeviceGroupsResponse_FieldMask) *WatchDeviceGroupsResponse_FieldMask {
	result := &WatchDeviceGroupsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchDeviceGroupsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchDeviceGroupsResponse_FieldPathSelectorPageTokenChange: &WatchDeviceGroupsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchDeviceGroupsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchDeviceGroupsResponse_FieldPathSelectorPageTokenChange: &WatchDeviceGroupsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeviceGroupsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchDeviceGroupsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchDeviceGroupsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchDeviceGroupsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchDeviceGroupsResponse_FieldPathSelectorPageTokenChange] = FullWatchDeviceGroupsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchDeviceGroupsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchDeviceGroupsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeviceGroupsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeviceGroupsResponse_FieldMask) FilterInputFields() *WatchDeviceGroupsResponse_FieldMask {
	result := &WatchDeviceGroupsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeviceGroupsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeviceGroupsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeviceGroupsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeviceGroupsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeviceGroupsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) AppendPath(path WatchDeviceGroupsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeviceGroupsResponse_FieldPath))
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) GetPaths() []WatchDeviceGroupsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeviceGroupsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) Set(target, source *WatchDeviceGroupsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeviceGroupsResponse), source.(*WatchDeviceGroupsResponse))
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) Project(source *WatchDeviceGroupsResponse) *WatchDeviceGroupsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeviceGroupsResponse{}
	pageTokenChangeMask := &WatchDeviceGroupsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeviceGroupsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchDeviceGroupsResponse_FieldPathSelectorDeviceGroupChanges:
				result.DeviceGroupChanges = source.DeviceGroupChanges
			case WatchDeviceGroupsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchDeviceGroupsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchDeviceGroupsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchDeviceGroupsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchDeviceGroupsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchDeviceGroupsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchDeviceGroupsResponse_FieldSubPath:
			switch tp.selector {
			case WatchDeviceGroupsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchDeviceGroupsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeviceGroupsResponse))
}

func (fieldMask *WatchDeviceGroupsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeviceGroupsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchDeviceGroupsResponsePageTokenChange_FieldPath
}

func FullWatchDeviceGroupsResponse_PageTokenChange_FieldMask() *WatchDeviceGroupsResponse_PageTokenChange_FieldMask {
	res := &WatchDeviceGroupsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeviceGroupsResponsePageTokenChange_FieldTerminalPath{selector: WatchDeviceGroupsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchDeviceGroupsResponsePageTokenChange_FieldTerminalPath{selector: WatchDeviceGroupsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeviceGroupsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeviceGroupsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeviceGroupsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) Subtract(other *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) *WatchDeviceGroupsResponse_PageTokenChange_FieldMask {
	result := &WatchDeviceGroupsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeviceGroupsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeviceGroupsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchDeviceGroupsResponse_PageTokenChange_FieldMask {
	result := &WatchDeviceGroupsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeviceGroupsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeviceGroupsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeviceGroupsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeviceGroupsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) AppendPath(path WatchDeviceGroupsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeviceGroupsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) GetPaths() []WatchDeviceGroupsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeviceGroupsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) Set(target, source *WatchDeviceGroupsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeviceGroupsResponse_PageTokenChange), source.(*WatchDeviceGroupsResponse_PageTokenChange))
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) Project(source *WatchDeviceGroupsResponse_PageTokenChange) *WatchDeviceGroupsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeviceGroupsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeviceGroupsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchDeviceGroupsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchDeviceGroupsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeviceGroupsResponse_PageTokenChange))
}

func (fieldMask *WatchDeviceGroupsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateDeviceGroupRequest_FieldMask struct {
	Paths []CreateDeviceGroupRequest_FieldPath
}

func FullCreateDeviceGroupRequest_FieldMask() *CreateDeviceGroupRequest_FieldMask {
	res := &CreateDeviceGroupRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateDeviceGroupRequest_FieldTerminalPath{selector: CreateDeviceGroupRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateDeviceGroupRequest_FieldTerminalPath{selector: CreateDeviceGroupRequest_FieldPathSelectorDeviceGroup})
	return res
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateDeviceGroupRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateDeviceGroupRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateDeviceGroupRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateDeviceGroupRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) Subtract(other *CreateDeviceGroupRequest_FieldMask) *CreateDeviceGroupRequest_FieldMask {
	result := &CreateDeviceGroupRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateDeviceGroupRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateDeviceGroupRequest_FieldPathSelectorDeviceGroup: &device_group.DeviceGroup_FieldMask{},
	}
	mySubMasks := map[CreateDeviceGroupRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateDeviceGroupRequest_FieldPathSelectorDeviceGroup: &device_group.DeviceGroup_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateDeviceGroupRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateDeviceGroupRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateDeviceGroupRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateDeviceGroupRequest_FieldPathSelectorDeviceGroup:
						mySubMasks[CreateDeviceGroupRequest_FieldPathSelectorDeviceGroup] = device_group.FullDeviceGroup_FieldMask()
					}
				} else if tp, ok := path.(*CreateDeviceGroupRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateDeviceGroupRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateDeviceGroupRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateDeviceGroupRequest_FieldMask) FilterInputFields() *CreateDeviceGroupRequest_FieldMask {
	result := &CreateDeviceGroupRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateDeviceGroupRequest_FieldPathSelectorDeviceGroup:
			if _, ok := path.(*CreateDeviceGroupRequest_FieldTerminalPath); ok {
				for _, subpath := range device_group.FullDeviceGroup_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateDeviceGroupRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateDeviceGroupRequest_FieldSubPath); ok {
				selectedMask := &device_group.DeviceGroup_FieldMask{
					Paths: []device_group.DeviceGroup_FieldPath{sub.subPath.(device_group.DeviceGroup_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateDeviceGroupRequest_FieldSubPath{selector: CreateDeviceGroupRequest_FieldPathSelectorDeviceGroup, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateDeviceGroupRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateDeviceGroupRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateDeviceGroupRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateDeviceGroupRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateDeviceGroupRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) AppendPath(path CreateDeviceGroupRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateDeviceGroupRequest_FieldPath))
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) GetPaths() []CreateDeviceGroupRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateDeviceGroupRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) Set(target, source *CreateDeviceGroupRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateDeviceGroupRequest), source.(*CreateDeviceGroupRequest))
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) Project(source *CreateDeviceGroupRequest) *CreateDeviceGroupRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateDeviceGroupRequest{}
	deviceGroupMask := &device_group.DeviceGroup_FieldMask{}
	wholeDeviceGroupAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateDeviceGroupRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateDeviceGroupRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateDeviceGroupRequest_FieldPathSelectorDeviceGroup:
				result.DeviceGroup = source.DeviceGroup
				wholeDeviceGroupAccepted = true
			}
		case *CreateDeviceGroupRequest_FieldSubPath:
			switch tp.selector {
			case CreateDeviceGroupRequest_FieldPathSelectorDeviceGroup:
				deviceGroupMask.AppendPath(tp.subPath.(device_group.DeviceGroup_FieldPath))
			}
		}
	}
	if wholeDeviceGroupAccepted == false && len(deviceGroupMask.Paths) > 0 {
		result.DeviceGroup = deviceGroupMask.Project(source.GetDeviceGroup())
	}
	return result
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateDeviceGroupRequest))
}

func (fieldMask *CreateDeviceGroupRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateDeviceGroupRequest_FieldMask struct {
	Paths []UpdateDeviceGroupRequest_FieldPath
}

func FullUpdateDeviceGroupRequest_FieldMask() *UpdateDeviceGroupRequest_FieldMask {
	res := &UpdateDeviceGroupRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateDeviceGroupRequest_FieldTerminalPath{selector: UpdateDeviceGroupRequest_FieldPathSelectorDeviceGroup})
	res.Paths = append(res.Paths, &UpdateDeviceGroupRequest_FieldTerminalPath{selector: UpdateDeviceGroupRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateDeviceGroupRequest_FieldTerminalPath{selector: UpdateDeviceGroupRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateDeviceGroupRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateDeviceGroupRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateDeviceGroupRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateDeviceGroupRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) Subtract(other *UpdateDeviceGroupRequest_FieldMask) *UpdateDeviceGroupRequest_FieldMask {
	result := &UpdateDeviceGroupRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateDeviceGroupRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateDeviceGroupRequest_FieldPathSelectorDeviceGroup: &device_group.DeviceGroup_FieldMask{},
		UpdateDeviceGroupRequest_FieldPathSelectorCas:         &UpdateDeviceGroupRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateDeviceGroupRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateDeviceGroupRequest_FieldPathSelectorDeviceGroup: &device_group.DeviceGroup_FieldMask{},
		UpdateDeviceGroupRequest_FieldPathSelectorCas:         &UpdateDeviceGroupRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateDeviceGroupRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateDeviceGroupRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateDeviceGroupRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateDeviceGroupRequest_FieldPathSelectorDeviceGroup:
						mySubMasks[UpdateDeviceGroupRequest_FieldPathSelectorDeviceGroup] = device_group.FullDeviceGroup_FieldMask()
					case UpdateDeviceGroupRequest_FieldPathSelectorCas:
						mySubMasks[UpdateDeviceGroupRequest_FieldPathSelectorCas] = FullUpdateDeviceGroupRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateDeviceGroupRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateDeviceGroupRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateDeviceGroupRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateDeviceGroupRequest_FieldMask) FilterInputFields() *UpdateDeviceGroupRequest_FieldMask {
	result := &UpdateDeviceGroupRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateDeviceGroupRequest_FieldPathSelectorDeviceGroup:
			if _, ok := path.(*UpdateDeviceGroupRequest_FieldTerminalPath); ok {
				for _, subpath := range device_group.FullDeviceGroup_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeviceGroupRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateDeviceGroupRequest_FieldSubPath); ok {
				selectedMask := &device_group.DeviceGroup_FieldMask{
					Paths: []device_group.DeviceGroup_FieldPath{sub.subPath.(device_group.DeviceGroup_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeviceGroupRequest_FieldSubPath{selector: UpdateDeviceGroupRequest_FieldPathSelectorDeviceGroup, subPath: allowedPath})
				}
			}
		case UpdateDeviceGroupRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateDeviceGroupRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateDeviceGroupRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeviceGroupRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateDeviceGroupRequest_FieldSubPath); ok {
				selectedMask := &UpdateDeviceGroupRequest_CAS_FieldMask{
					Paths: []UpdateDeviceGroupRequestCAS_FieldPath{sub.subPath.(UpdateDeviceGroupRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeviceGroupRequest_FieldSubPath{selector: UpdateDeviceGroupRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateDeviceGroupRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateDeviceGroupRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateDeviceGroupRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateDeviceGroupRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateDeviceGroupRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) AppendPath(path UpdateDeviceGroupRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateDeviceGroupRequest_FieldPath))
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) GetPaths() []UpdateDeviceGroupRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateDeviceGroupRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) Set(target, source *UpdateDeviceGroupRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateDeviceGroupRequest), source.(*UpdateDeviceGroupRequest))
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) Project(source *UpdateDeviceGroupRequest) *UpdateDeviceGroupRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateDeviceGroupRequest{}
	deviceGroupMask := &device_group.DeviceGroup_FieldMask{}
	wholeDeviceGroupAccepted := false
	casMask := &UpdateDeviceGroupRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateDeviceGroupRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateDeviceGroupRequest_FieldPathSelectorDeviceGroup:
				result.DeviceGroup = source.DeviceGroup
				wholeDeviceGroupAccepted = true
			case UpdateDeviceGroupRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateDeviceGroupRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateDeviceGroupRequest_FieldSubPath:
			switch tp.selector {
			case UpdateDeviceGroupRequest_FieldPathSelectorDeviceGroup:
				deviceGroupMask.AppendPath(tp.subPath.(device_group.DeviceGroup_FieldPath))
			case UpdateDeviceGroupRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateDeviceGroupRequestCAS_FieldPath))
			}
		}
	}
	if wholeDeviceGroupAccepted == false && len(deviceGroupMask.Paths) > 0 {
		result.DeviceGroup = deviceGroupMask.Project(source.GetDeviceGroup())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateDeviceGroupRequest))
}

func (fieldMask *UpdateDeviceGroupRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateDeviceGroupRequest_CAS_FieldMask struct {
	Paths []UpdateDeviceGroupRequestCAS_FieldPath
}

func FullUpdateDeviceGroupRequest_CAS_FieldMask() *UpdateDeviceGroupRequest_CAS_FieldMask {
	res := &UpdateDeviceGroupRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateDeviceGroupRequestCAS_FieldTerminalPath{selector: UpdateDeviceGroupRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateDeviceGroupRequestCAS_FieldTerminalPath{selector: UpdateDeviceGroupRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateDeviceGroupRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateDeviceGroupRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateDeviceGroupRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) Subtract(other *UpdateDeviceGroupRequest_CAS_FieldMask) *UpdateDeviceGroupRequest_CAS_FieldMask {
	result := &UpdateDeviceGroupRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateDeviceGroupRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateDeviceGroupRequestCAS_FieldPathSelectorConditionalState: &device_group.DeviceGroup_FieldMask{},
	}
	mySubMasks := map[UpdateDeviceGroupRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateDeviceGroupRequestCAS_FieldPathSelectorConditionalState: &device_group.DeviceGroup_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateDeviceGroupRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateDeviceGroupRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateDeviceGroupRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateDeviceGroupRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateDeviceGroupRequestCAS_FieldPathSelectorConditionalState] = device_group.FullDeviceGroup_FieldMask()
					}
				} else if tp, ok := path.(*UpdateDeviceGroupRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateDeviceGroupRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateDeviceGroupRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) FilterInputFields() *UpdateDeviceGroupRequest_CAS_FieldMask {
	result := &UpdateDeviceGroupRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateDeviceGroupRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateDeviceGroupRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range device_group.FullDeviceGroup_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeviceGroupRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateDeviceGroupRequestCAS_FieldSubPath); ok {
				selectedMask := &device_group.DeviceGroup_FieldMask{
					Paths: []device_group.DeviceGroup_FieldPath{sub.subPath.(device_group.DeviceGroup_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeviceGroupRequestCAS_FieldSubPath{selector: UpdateDeviceGroupRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateDeviceGroupRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateDeviceGroupRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateDeviceGroupRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateDeviceGroupRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) AppendPath(path UpdateDeviceGroupRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateDeviceGroupRequestCAS_FieldPath))
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) GetPaths() []UpdateDeviceGroupRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateDeviceGroupRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) Set(target, source *UpdateDeviceGroupRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateDeviceGroupRequest_CAS), source.(*UpdateDeviceGroupRequest_CAS))
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) Project(source *UpdateDeviceGroupRequest_CAS) *UpdateDeviceGroupRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateDeviceGroupRequest_CAS{}
	conditionalStateMask := &device_group.DeviceGroup_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateDeviceGroupRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateDeviceGroupRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateDeviceGroupRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateDeviceGroupRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateDeviceGroupRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(device_group.DeviceGroup_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateDeviceGroupRequest_CAS))
}

func (fieldMask *UpdateDeviceGroupRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteDeviceGroupRequest_FieldMask struct {
	Paths []DeleteDeviceGroupRequest_FieldPath
}

func FullDeleteDeviceGroupRequest_FieldMask() *DeleteDeviceGroupRequest_FieldMask {
	res := &DeleteDeviceGroupRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteDeviceGroupRequest_FieldTerminalPath{selector: DeleteDeviceGroupRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteDeviceGroupRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteDeviceGroupRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteDeviceGroupRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteDeviceGroupRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) Subtract(other *DeleteDeviceGroupRequest_FieldMask) *DeleteDeviceGroupRequest_FieldMask {
	result := &DeleteDeviceGroupRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteDeviceGroupRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteDeviceGroupRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteDeviceGroupRequest_FieldMask) FilterInputFields() *DeleteDeviceGroupRequest_FieldMask {
	result := &DeleteDeviceGroupRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteDeviceGroupRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteDeviceGroupRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteDeviceGroupRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteDeviceGroupRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteDeviceGroupRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) AppendPath(path DeleteDeviceGroupRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteDeviceGroupRequest_FieldPath))
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) GetPaths() []DeleteDeviceGroupRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteDeviceGroupRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) Set(target, source *DeleteDeviceGroupRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteDeviceGroupRequest), source.(*DeleteDeviceGroupRequest))
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) Project(source *DeleteDeviceGroupRequest) *DeleteDeviceGroupRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteDeviceGroupRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteDeviceGroupRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteDeviceGroupRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteDeviceGroupRequest))
}

func (fieldMask *DeleteDeviceGroupRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
